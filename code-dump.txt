# ðŸ“¦ Code Dump of "course-management-platform"



/* ========== docs\postman_collection.json ========== */
```json
{
  "info": {
    "name": "Course Management Platform API - Complete",
    "description": "Complete API collection for testing the Course Management Platform backend service with all implemented endpoints",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{access_token}}",
        "type": "string"
      }
    ]
  },
  "event": [
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Save token from login/register responses",
          "if (pm.response.json().tokens) {",
          "    pm.environment.set('access_token', pm.response.json().tokens.accessToken);",
          "    pm.environment.set('refresh_token', pm.response.json().tokens.refreshToken);",
          "}",
          "",
          "// Basic status check",
          "pm.test('Response status is valid', function () {",
          "    pm.expect(pm.response.code).to.be.oneOf([200, 201, 204]);",
          "});",
          "",
          "// Response time check",
          "pm.test('Response time is acceptable', function () {",
          "    pm.expect(pm.response.responseTime).to.be.below(3000);",
          "});"
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:3000/api"
    }
  ],
  "item": [
    {
      "name": "System",
      "item": [
        {
          "name": "Health Check",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/../health",
              "host": ["{{baseUrl}}"],
              "path": ["..", "health"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Health check passes', function () {",
                  "    pm.response.to.have.status(200);",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.status).to.eql('OK');",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "API Root",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}",
              "host": ["{{baseUrl}}"]
            }
          }
        }
      ]
    },
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Register Manager",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"manager@university.edu\",\n  \"password\": \"SecurePass123!\",\n  \"firstName\": \"Jane\",\n  \"lastName\": \"Manager\",\n  \"role\": \"manager\",\n  \"employeeId\": \"MGR001\",\n  \"department\": \"Computer Science\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/register",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "register"]
            }
          }
        },
        {
          "name": "Register Facilitator",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"john.doe@university.edu\",\n  \"password\": \"SecurePass123!\",\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\",\n  \"role\": \"facilitator\",\n  \"employeeId\": \"EMP001\",\n  \"department\": \"Computer Science\",\n  \"specialization\": \"Software Development\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/register",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "register"]
            }
          }
        },
        {
          "name": "Register Student",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"student@university.edu\",\n  \"password\": \"SecurePass123!\",\n  \"firstName\": \"Alice\",\n  \"lastName\": \"Student\",\n  \"role\": \"student\",\n  \"studentId\": \"STU001\",\n  \"cohortId\": 1\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/register",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "register"]
            }
          }
        },
        {
          "name": "Login Manager",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"manager@university.edu\",\n  \"password\": \"SecurePass123!\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "login"]
            }
          }
        },
        {
          "name": "Login Facilitator",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"john.doe@university.edu\",\n  \"password\": \"SecurePass123!\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "login"]
            }
          }
        },
        {
          "name": "Get Profile",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/auth/profile",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "profile"]
            }
          }
        },
        {
          "name": "Update Profile",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"firstName\": \"John Updated\",\n  \"lastName\": \"Doe Updated\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/profile",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "profile"]
            }
          }
        },
        {
          "name": "Refresh Token",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"refreshToken\": \"{{refresh_token}}\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/refresh",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "refresh"]
            }
          }
        },
        {
          "name": "Change Password",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"currentPassword\": \"SecurePass123!\",\n  \"newPassword\": \"NewSecurePass456!\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/change-password",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "change-password"]
            }
          }
        },
        {
          "name": "Logout",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/auth/logout",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "logout"]
            }
          }
        }
      ]
    },
    {
      "name": "User Management",
      "item": [
        {
          "name": "Get All Users (Admin)",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["users"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Get All Users with Search",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users?search=john&role=facilitator",
              "host": ["{{baseUrl}}"],
              "path": ["users"],
              "query": [
                {
                  "key": "search",
                  "value": "john"
                },
                {
                  "key": "role",
                  "value": "facilitator"
                }
              ]
            }
          }
        },
        {
          "name": "Get User by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/1",
              "host": ["{{baseUrl}}"],
              "path": ["users", "1"]
            }
          }
        },
        {
          "name": "Update User (Admin)",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"firstName\": \"Updated First\",\n  \"lastName\": \"Updated Last\",\n  \"isActive\": true\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/users/1",
              "host": ["{{baseUrl}}"],
              "path": ["users", "1"]
            }
          }
        },
        {
          "name": "Deactivate User",
          "request": {
            "method": "PATCH",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/1/deactivate",
              "host": ["{{baseUrl}}"],
              "path": ["users", "1", "deactivate"]
            }
          }
        },
        {
          "name": "Delete User",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/1",
              "host": ["{{baseUrl}}"],
              "path": ["users", "1"]
            }
          }
        },
        {
          "name": "Get All Facilitators",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/facilitators",
              "host": ["{{baseUrl}}"],
              "path": ["users", "facilitators"]
            }
          }
        },
        {
          "name": "Get All Students",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/students",
              "host": ["{{baseUrl}}"],
              "path": ["users", "students"]
            }
          }
        },
        {
          "name": "Get User Statistics",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/stats",
              "host": ["{{baseUrl}}"],
              "path": ["users", "stats"]
            }
          }
        }
      ]
    },
    {
      "name": "Course Management",
      "item": [
        {
          "name": "Get All Modules",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/modules",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "modules"]
            }
          }
        },
        {
          "name": "Create Module",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"code\": \"CS101\",\n  \"name\": \"Introduction to Computer Science\",\n  \"description\": \"Basic concepts of computer science\",\n  \"credits\": 3,\n  \"level\": \"100\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses/modules",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "modules"]
            }
          }
        },
        {
          "name": "Create Additional Modules",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"code\": \"CS201\",\n  \"name\": \"Data Structures and Algorithms\",\n  \"description\": \"Study of data organization and algorithmic thinking\",\n  \"credits\": 4,\n  \"level\": \"200\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses/modules",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "modules"]
            }
          }
        },
        {
          "name": "Get All Course Offerings",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["courses"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Get Course Offerings with Filters",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses?trimester=1&status=active&facilitatorId=1",
              "host": ["{{baseUrl}}"],
              "path": ["courses"],
              "query": [
                {
                  "key": "trimester",
                  "value": "1"
                },
                {
                  "key": "status",
                  "value": "active"
                },
                {
                  "key": "facilitatorId",
                  "value": "1"
                }
              ]
            }
          }
        },
        {
          "name": "Create Course Offering",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"moduleId\": 1,\n  \"classId\": 1,\n  \"cohortId\": 1,\n  \"facilitatorId\": 1,\n  \"modeId\": 1,\n  \"trimester\": 1,\n  \"intakePeriod\": \"HT1\",\n  \"startDate\": \"2025-09-01\",\n  \"endDate\": \"2025-12-15\",\n  \"maxStudents\": 30\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses",
              "host": ["{{baseUrl}}"],
              "path": ["courses"]
            }
          }
        },
        {
          "name": "Get Course Offering by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/1",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "1"]
            }
          }
        },
        {
          "name": "Update Course Offering",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"active\",\n  \"maxStudents\": 35\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses/1",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "1"]
            }
          }
        },
        {
          "name": "Delete Course Offering",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/1",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "1"]
            }
          }
        },
        {
          "name": "Assign Facilitator",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"facilitatorId\": 1\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses/1/assign-facilitator",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "1", "assign-facilitator"]
            }
          }
        },
        {
          "name": "Get My Assigned Courses (Facilitator)",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/my-courses",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "my-courses"]
            }
          }
        }
      ]
    },
    {
      "name": "Activity Tracking",
      "item": [
        {
          "name": "Get All Activity Logs",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["activities"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Get Activity Logs with Filters",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities?weekNumber=1&facilitatorId=1&status=complete",
              "host": ["{{baseUrl}}"],
              "path": ["activities"],
              "query": [
                {
                  "key": "weekNumber",
                  "value": "1"
                },
                {
                  "key": "facilitatorId",
                  "value": "1"
                },
                {
                  "key": "status",
                  "value": "complete"
                }
              ]
            }
          }
        },
        {
          "name": "Create Activity Log",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"allocationId\": 1,\n  \"weekNumber\": 1,\n  \"attendance\": [true, true, false, true, true],\n  \"formativeOneGrading\": \"Done\",\n  \"formativeTwoGrading\": \"Pending\",\n  \"summativeGrading\": \"Not Started\",\n  \"courseModeration\": \"Done\",\n  \"intranetSync\": \"Done\",\n  \"gradeBookStatus\": \"Pending\",\n  \"notes\": \"Student 3 was sick\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/activities",
              "host": ["{{baseUrl}}"],
              "path": ["activities"]
            }
          }
        },
        {
          "name": "Get Activity Log by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities/1",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "1"]
            }
          }
        },
        {
          "name": "Update Activity Log",
          "request": {
            "method": "PUT",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"formativeTwoGrading\": \"Done\",\n  \"summativeGrading\": \"Done\",\n  \"gradeBookStatus\": \"Done\",\n  \"notes\": \"All tasks completed\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/activities/1",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "1"]
            }
          }
        },
        {
          "name": "Delete Activity Log (Manager)",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities/1",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "1"]
            }
          }
        },
        {
          "name": "Get My Activity Logs (Facilitator)",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities/my-logs",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "my-logs"]
            }
          }
        },
        {
          "name": "Get My Activity Logs with Filter",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities/my-logs?weekNumber=1&allocationId=1",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "my-logs"],
              "query": [
                {
                  "key": "weekNumber",
                  "value": "1"
                },
                {
                  "key": "allocationId",
                  "value": "1"
                }
              ]
            }
          }
        },
        {
          "name": "Get Weekly Summary (Manager)",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/activities/summary?weekNumber=1",
              "host": ["{{baseUrl}}"],
              "path": ["activities", "summary"],
              "query": [
                {
                  "key": "weekNumber",
                  "value": "1"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "name": "Test Data Setup",
      "description": "Requests to create test data needed for course offerings",
      "item": [
        {
          "name": "Create Test Class",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"2025S\",\n  \"year\": 2025,\n  \"section\": \"S\",\n  \"description\": \"Spring 2025\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/classes",
              "host": ["{{baseUrl}}"],
              "path": ["classes"]
            }
          }
        },
        {
          "name": "Create Test Cohort",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Computer Science 2025\",\n  \"code\": \"CS2025\",\n  \"startDate\": \"2025-01-01\",\n  \"endDate\": \"2028-12-31\",\n  \"program\": \"Computer Science\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/cohorts",
              "host": ["{{baseUrl}}"],
              "path": ["cohorts"]
            }
          }
        },
        {
          "name": "Create Test Mode",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Online\",\n  \"description\": \"Online delivery\",\n  \"requiresPhysicalPresence\": false\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/modes",
              "host": ["{{baseUrl}}"],
              "path": ["modes"]
            }
          }
        },
        {
          "name": "Create In-Person Mode",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"In-person\",\n  \"description\": \"Traditional classroom delivery\",\n  \"requiresPhysicalPresence\": true\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/modes",
              "host": ["{{baseUrl}}"],
              "path": ["modes"]
            }
          }
        },
        {
          "name": "Seed Database",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/seed",
              "host": ["{{baseUrl}}"],
              "path": ["seed"]
            }
          }
        }
      ]
    },
    {
      "name": "Error Testing",
      "description": "Requests to test error handling and validation",
      "item": [
        {
          "name": "Invalid Login",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"wrong@email.com\",\n  \"password\": \"wrongpassword\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "login"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Invalid login returns 401', function () {",
                  "    pm.response.to.have.status(401);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Invalid Module Data",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"code\": \"\",\n  \"name\": \"Test Module\",\n  \"credits\": -1,\n  \"level\": \"invalid\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/courses/modules",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "modules"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Invalid data returns 400', function () {",
                  "    pm.response.to.have.status(400);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Unauthorized Access (No Token)",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/modules",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "modules"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('No token returns 401', function () {",
                  "    pm.response.to.have.status(401);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Forbidden Access (Wrong Role)",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/1",
              "host": ["{{baseUrl}}"],
              "path": ["users", "1"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Wrong role returns 403', function () {",
                  "    pm.response.to.have.status(403);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        },
        {
          "name": "Not Found Resource",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/courses/99999",
              "host": ["{{baseUrl}}"],
              "path": ["courses", "99999"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('Non-existent resource returns 404', function () {",
                  "    pm.response.to.have.status(404);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Monitoring & Health",
      "description": "System monitoring and health check endpoints",
      "item": [
        {
          "name": "Redis Health Check",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/monitoring/redis",
              "host": ["{{baseUrl}}"],
              "path": ["monitoring", "redis"]
            }
          }
        },
        {
          "name": "MySQL Health Check",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/monitoring/mysql",
              "host": ["{{baseUrl}}"],
              "path": ["monitoring", "mysql"]
            }
          }
        },
        {
          "name": "Overall System Status",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/monitoring/status",
              "host": ["{{baseUrl}}"],
              "path": ["monitoring", "status"]
            }
          }
        },
        {
          "name": "Monitoring Dashboard",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/../monitoring",
              "host": ["{{baseUrl}}"],
              "path": ["..", "monitoring"]
            }
          }
        }
      ]
    },
    {
      "name": "Advanced Workflows",
      "description": "Complex testing workflows that combine multiple operations",
      "item": [
        {
          "name": "Complete Course Setup Workflow",
          "item": [
            {
              "name": "1. Login as Manager",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"manager@university.edu\",\n  \"password\": \"SecurePass123!\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": ["{{baseUrl}}"],
                  "path": ["auth", "login"]
                }
              }
            },
            {
              "name": "2. Create Module",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"code\": \"WF101\",\n  \"name\": \"Workflow Test Module\",\n  \"description\": \"Test module for workflow\",\n  \"credits\": 3,\n  \"level\": \"100\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/courses/modules",
                  "host": ["{{baseUrl}}"],
                  "path": ["courses", "modules"]
                }
              }
            },
            {
              "name": "3. Create Course Offering",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"moduleId\": \"{{module_id}}\",\n  \"classId\": 1,\n  \"cohortId\": 1,\n  \"facilitatorId\": 1,\n  \"modeId\": 1,\n  \"trimester\": 1,\n  \"intakePeriod\": \"HT1\",\n  \"startDate\": \"2025-09-01\",\n  \"endDate\": \"2025-12-15\",\n  \"maxStudents\": 30\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/courses",
                  "host": ["{{baseUrl}}"],
                  "path": ["courses"]
                }
              }
            },
            {
              "name": "4. Activate Course",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"status\": \"active\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/courses/{{course_id}}",
                  "host": ["{{baseUrl}}"],
                  "path": ["courses", "{{course_id}}"]
                }
              }
            }
          ]
        },
        {
          "name": "Complete Activity Tracking Workflow",
          "item": [
            {
              "name": "1. Login as Facilitator",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"email\": \"john.doe@university.edu\",\n  \"password\": \"SecurePass123!\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/auth/login",
                  "host": ["{{baseUrl}}"],
                  "path": ["auth", "login"]
                }
              }
            },
            {
              "name": "2. View My Courses",
              "request": {
                "method": "GET",
                "header": [],
                "url": {
                  "raw": "{{baseUrl}}/courses/my-courses",
                  "host": ["{{baseUrl}}"],
                  "path": ["courses", "my-courses"]
                }
              }
            },
            {
              "name": "3. Create Week 1 Activity",
              "request": {
                "method": "POST",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"allocationId\": \"{{course_id}}\",\n  \"weekNumber\": 1,\n  \"attendance\": [true, true, true, false, true],\n  \"formativeOneGrading\": \"Pending\",\n  \"formativeTwoGrading\": \"Not Started\",\n  \"summativeGrading\": \"Not Started\",\n  \"courseModeration\": \"Not Started\",\n  \"intranetSync\": \"Not Started\",\n  \"gradeBookStatus\": \"Not Started\",\n  \"notes\": \"Week 1 initial submission\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/activities",
                  "host": ["{{baseUrl}}"],
                  "path": ["activities"]
                }
              }
            },
            {
              "name": "4. Update Activity Progress",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"formativeOneGrading\": \"Done\",\n  \"formativeTwoGrading\": \"Done\",\n  \"courseModeration\": \"Done\",\n  \"notes\": \"Week 1 partially completed\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/activities/{{activity_id}}",
                  "host": ["{{baseUrl}}"],
                  "path": ["activities", "{{activity_id}}"]
                }
              }
            },
            {
              "name": "5. Complete All Tasks",
              "request": {
                "method": "PUT",
                "header": [
                  {
                    "key": "Content-Type",
                    "value": "application/json"
                  }
                ],
                "body": {
                  "mode": "raw",
                  "raw": "{\n  \"summativeGrading\": \"Done\",\n  \"intranetSync\": \"Done\",\n  \"gradeBookStatus\": \"Done\",\n  \"notes\": \"Week 1 fully completed\"\n}"
                },
                "url": {
                  "raw": "{{baseUrl}}/activities/{{activity_id}}",
                  "host": ["{{baseUrl}}"],
                  "path": ["activities", "{{activity_id}}"]
                }
              }
            }
          ]
        }
      ]
    }
  ]
}
```


/* ========== docs\swagger.json ========== */
```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Course Management Platform API",
    "version": "1.0.0",
    "description": "A comprehensive backend system for academic institutions to manage course allocations, track facilitator activities, and monitor student progress.",
    "contact": {
      "name": "API Support",
      "email": "support@coursemanagement.edu"
    },
    "license": {
      "name": "MIT",
      "url": "https://opensource.org/licenses/MIT"
    }
  },
  "servers": [
    {
      "url": "http://localhost:3000/api",
      "description": "Development server"
    },
    {
      "url": "https://api.coursemanagement.edu/api",
      "description": "Production server"
    }
  ],
  "components": {
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    },
    "schemas": {
      "User": {
        "type": "object",
        "properties": {
          "id": { "type": "integer" },
          "email": { "type": "string", "format": "email" },
          "firstName": { "type": "string" },
          "lastName": { "type": "string" },
          "role": { "type": "string", "enum": ["admin", "manager", "facilitator", "student"] },
          "isActive": { "type": "boolean" },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "Module": {
        "type": "object",
        "properties": {
          "id": { "type": "integer" },
          "code": { "type": "string" },
          "name": { "type": "string" },
          "description": { "type": "string" },
          "credits": { "type": "integer" },
          "level": { "type": "string", "enum": ["100", "200", "300", "400", "500", "600"] },
          "isActive": { "type": "boolean" }
        }
      },
      "CourseOffering": {
        "type": "object",
        "properties": {
          "id": { "type": "integer" },
          "moduleId": { "type": "integer" },
          "classId": { "type": "integer" },
          "cohortId": { "type": "integer" },
          "facilitatorId": { "type": "integer" },
          "modeId": { "type": "integer" },
          "trimester": { "type": "integer", "minimum": 1, "maximum": 3 },
          "intakePeriod": { "type": "string", "enum": ["HT1", "HT2", "FT"] },
          "startDate": { "type": "string", "format": "date" },
          "endDate": { "type": "string", "format": "date" },
          "maxStudents": { "type": "integer" },
          "enrolledStudents": { "type": "integer" },
          "status": { "type": "string", "enum": ["planned", "active", "completed", "cancelled"] }
        }
      },
      "ActivityTracker": {
        "type": "object",
        "properties": {
          "id": { "type": "integer" },
          "allocationId": { "type": "integer" },
          "weekNumber": { "type": "integer", "minimum": 1, "maximum": 16 },
          "attendance": { "type": "array", "items": { "type": "boolean" } },
          "formativeOneGrading": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "formativeTwoGrading": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "summativeGrading": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "courseModeration": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "intranetSync": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "gradeBookStatus": { "type": "string", "enum": ["Done", "Pending", "Not Started"] },
          "submittedAt": { "type": "string", "format": "date-time" },
          "notes": { "type": "string" }
        }
      },
      "PaginationResponse": {
        "type": "object",
        "properties": {
          "total": { 
            "type": "integer", 
            "description": "Total number of items" 
          },
          "page": { 
            "type": "integer", 
            "description": "Current page number" 
          },
          "limit": { 
            "type": "integer", 
            "description": "Number of items per page" 
          },
          "pages": { 
            "type": "integer", 
            "description": "Total number of pages" 
          },
          "hasNext": { 
            "type": "boolean", 
            "description": "Whether there is a next page" 
          },
          "hasPrev": { 
            "type": "boolean", 
            "description": "Whether there is a previous page" 
          }
        },
        "required": ["total", "page", "limit", "pages", "hasNext", "hasPrev"]
      },
      "Error": {
        "type": "object",
        "properties": {
          "error": { "type": "string" },
          "message": { "type": "string" },
          "errors": { "type": "array", "items": { "type": "object" } }
        }
      },
      "LoginRequest": {
        "type": "object",
        "required": ["email", "password"],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "User's email address"
          },
          "password": {
            "type": "string",
            "description": "User's password"
          }
        }
      },
      "RegisterRequest": {
        "type": "object",
        "required": ["email", "password", "firstName", "lastName", "role"],
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "description": "User's email address"
          },
          "password": {
            "type": "string",
            "minLength": 8,
            "description": "User's password (minimum 8 characters)"
          },
          "firstName": {
            "type": "string",
            "description": "User's first name"
          },
          "lastName": {
            "type": "string",
            "description": "User's last name"
          },
          "role": {
            "type": "string",
            "enum": ["admin", "manager", "facilitator", "student"],
            "description": "User's role in the system"
          },
          "employeeId": {
            "type": "string",
            "description": "Employee ID (for managers and facilitators)"
          },
          "department": {
            "type": "string",
            "description": "Department (for managers and facilitators)"
          },
          "specialization": {
            "type": "string",
            "description": "Specialization (for facilitators)"
          },
          "studentId": {
            "type": "string",
            "description": "Student ID (for students)"
          },
          "cohortId": {
            "type": "integer",
            "description": "Cohort ID (for students)"
          }
        }
      },
      "AuthResponse": {
        "type": "object",
        "properties": {
          "message": { "type": "string" },
          "user": { "$ref": "#/components/schemas/User" },
          "tokens": {
            "type": "object",
            "properties": {
              "accessToken": { "type": "string" },
              "refreshToken": { "type": "string" }
            }
          }
        }
      },
      "ApiResponse": {
        "type": "object",
        "properties": {
          "message": { "type": "string" },
          "data": { "type": "object" }
        }
      }
    }
  },
  "security": [
    {
      "bearerAuth": []
    }
  ],
  "tags": [
    {
      "name": "Authentication",
      "description": "User authentication and authorization"
    },
    {
      "name": "Users",
      "description": "User management operations"
    },
    {
      "name": "Courses",
      "description": "Course and module management"
    },
    {
      "name": "Activities",
      "description": "Activity tracking and monitoring"
    }
  ]
}
```


/* ========== dump-project-code.js ========== */
```javascript
const fs = require("fs");
const path = require("path");

const OUTPUT_FILE = "code-dump.txt";

const EXCLUDED_DIRS = [
  "node_modules", ".git", "dist", "build", "coverage",
  ".vscode", ".idea", "uploads", "public/assets"
];

const EXCLUDED_FILES = [
  OUTPUT_FILE, "package-lock.json", "yarn.lock", ".DS_Store"
];

const SKIP_EXTENSIONS = [
  ".png", ".jpg", ".jpeg", ".webp", ".svg",
  ".ico", ".mp4", ".mp3", ".ttf", ".woff", ".woff2", ".zip"
];

const languageMap = {
  ".js": "javascript",
  ".ts": "typescript",
  ".json": "json",
  ".html": "html",
  ".css": "css",
  ".env": "bash",
  ".md": "markdown",
};

function getLanguage(ext) {
  return languageMap[ext.toLowerCase()] || "";
}

function shouldSkipFile(fileName, ext) {
  return (
    EXCLUDED_FILES.includes(fileName) ||
    SKIP_EXTENSIONS.includes(ext.toLowerCase()) ||
    fileName.startsWith(".") // skip hidden files
  );
}

function dumpDirectoryContents(dirPath, writeStream) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const relativePath = path.relative(process.cwd(), fullPath);

    if (entry.isDirectory()) {
      if (!EXCLUDED_DIRS.includes(entry.name) && !entry.name.startsWith(".")) {
        dumpDirectoryContents(fullPath, writeStream);
      }
    } else {
      const ext = path.extname(entry.name);
      if (!shouldSkipFile(entry.name, ext)) {
        try {
          const content = fs.readFileSync(fullPath, "utf8");
          const lang = getLanguage(ext);

          writeStream.write(`\n\n/* ========== ${relativePath} ========== */\n`);
          writeStream.write(`\`\`\`${lang}\n${content.trim()}\n\`\`\`\n`);
        } catch (err) {
          console.error(`âŒ Failed to read: ${relativePath}`, err.message);
        }
      }
    }
  }
}

// Create the output stream
const output = fs.createWriteStream(OUTPUT_FILE);
output.write(`# ðŸ“¦ Code Dump of "${path.basename(process.cwd())}"\n\n`);

dumpDirectoryContents(process.cwd(), output);

output.end(() => {
  console.log(`âœ… Code dump complete! Saved to: ${OUTPUT_FILE}`);
});
```


/* ========== jest.config.js ========== */
```javascript
module.exports = {
  testEnvironment: 'node',
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/config/**',
    '!src/app.js',
    '!src/server.js'
  ],
  testMatch: [
    '**/tests/**/*.test.js',
    '**/?(*.)+(spec|test).js'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  verbose: true
};
```


/* ========== package.json ========== */
```json
{
  "name": "course-management-platform",
  "version": "1.0.0",
  "description": "Multi-feature backend system for Course Management Platform",
  "main": "server.js",
  "private": true,
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "worker": "node src/workers/notificationWorker.js",
    "seed": "node src/utils/seedDatabase.js",
    "migrate": "sequelize db:migrate",
    "migrate:undo": "sequelize db:migrate:undo",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix"
  },
  "keywords": [
    "course-management",
    "backend",
    "nodejs",
    "express",
    "mysql",
    "redis"
  ],
  "author": "Course Management Team",
  "license": "MIT",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.2",
    "bull": "^4.11.5",
    "cors": "^2.8.5",
    "cron": "^3.1.6",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "express-validator": "^7.0.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "mysql2": "^3.6.5",
    "nodemailer": "^6.9.7",
    "redis": "^4.6.11",
    "sequelize": "^6.35.1",
    "sequelize-erd": "^1.3.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.0",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.10",
    "eslint": "^8.55.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "sequelize-cli": "^6.6.2",
    "supertest": "^6.3.3"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  }
}
```


/* ========== public\index.html ========== */
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Course Management Platform - Student Reflection Page">
    <meta name="keywords" content="education, course, reflection, multilingual">
    <title>Course Reflection - Student Portal</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <!-- Language Switcher -->
        <div class="language-switcher">
            <button class="lang-btn active" data-lang="en">English</button>
            <button class="lang-btn" data-lang="fr">FranÃ§ais</button>
        </div>

        <!-- Header Section -->
        <header>
            <h1 id="page-title">Course Reflection</h1>
            <p id="welcome-message">Welcome to your course reflection page</p>
        </header>

        <!-- Main Content -->
        <main>
            <section class="reflection-section">
                <h2 id="reflection-heading">Share Your Experience</h2>

                <!-- Question 1 -->
                <div class="question-block">
                    <h3 id="question-1">What did you enjoy most about the course?</h3>
                    <textarea id="answer-1" class="answer-textarea" rows="4"
                        placeholder="Type your answer here..."></textarea>
                </div>

                <!-- Question 2 -->
                <div class="question-block">
                    <h3 id="question-2">What was the most challenging part?</h3>
                    <textarea id="answer-2" class="answer-textarea" rows="4"
                        placeholder="Type your answer here..."></textarea>
                </div>

                <!-- Question 3 -->
                <div class="question-block">
                    <h3 id="question-3">What could be improved?</h3>
                    <textarea id="answer-3" class="answer-textarea" rows="4"
                        placeholder="Type your answer here..."></textarea>
                </div>

                <!-- Submit Button -->
                <div class="submit-section">
                    <button id="submit-btn" class="submit-button">Submit Reflection</button>
                    <p id="submit-message" class="submit-message hidden"></p>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p id="footer-text">Â© 2025 Course Management Platform. All rights reserved.</p>
        </footer>
    </div>

    <script src="translations.js"></script>
    <script src="index.js"></script>
</body>

</html>
```


/* ========== public\index.js ========== */
```javascript
// Language management
let currentLanguage = 'en';
const STORAGE_KEY = 'preferredLanguage';

// DOM elements
const elements = {
    pageTitle: document.getElementById('page-title'),
    welcomeMessage: document.getElementById('welcome-message'),
    reflectionHeading: document.getElementById('reflection-heading'),
    question1: document.getElementById('question-1'),
    question2: document.getElementById('question-2'),
    question3: document.getElementById('question-3'),
    answer1: document.getElementById('answer-1'),
    answer2: document.getElementById('answer-2'),
    answer3: document.getElementById('answer-3'),
    submitButton: document.getElementById('submit-btn'),
    submitMessage: document.getElementById('submit-message'),
    footerText: document.getElementById('footer-text'),
    languageButtons: document.querySelectorAll('.lang-btn')
};

// Initialize the page
document.addEventListener('DOMContentLoaded', () => {
    initializeLanguage();
    setupEventListeners();
    loadSavedAnswers();
});

// Initialize language from localStorage or browser preference
function initializeLanguage() {
    // Check localStorage first
    const savedLanguage = localStorage.getItem(STORAGE_KEY);
    if (savedLanguage && translations[savedLanguage]) {
        currentLanguage = savedLanguage;
    } else {
        // Try to detect browser language
        const browserLang = navigator.language.substring(0, 2);
        if (translations[browserLang]) {
            currentLanguage = browserLang;
        }
    }
    
    updateLanguage(currentLanguage);
    updateActiveLanguageButton();
}

// Set up event listeners
function setupEventListeners() {
    // Language switcher
    elements.languageButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const lang = e.target.getAttribute('data-lang');
            switchLanguage(lang);
        });
    });
    
    // Submit button
    elements.submitButton.addEventListener('click', handleSubmit);
    
    // Auto-save answers
    [elements.answer1, elements.answer2, elements.answer3].forEach((textarea, index) => {
        textarea.addEventListener('input', () => {
            saveAnswerToLocalStorage(index + 1, textarea.value);
        });
    });
}

// Switch language
function switchLanguage(lang) {
    if (translations[lang]) {
        currentLanguage = lang;
        localStorage.setItem(STORAGE_KEY, lang);
        updateLanguage(lang);
        updateActiveLanguageButton();
    }
}

// Update page content with translations
function updateLanguage(lang) {
    const t = translations[lang];
    
    // Update text content
    document.title = t.pageTitle;
    elements.pageTitle.textContent = t.pageTitle;
    elements.welcomeMessage.textContent = t.welcomeMessage;
    elements.reflectionHeading.textContent = t.reflectionHeading;
    elements.question1.textContent = t.question1;
    elements.question2.textContent = t.question2;
    elements.question3.textContent = t.question3;
    elements.submitButton.textContent = t.submitButton;
    elements.footerText.textContent = t.footerText;
    
    // Update placeholders
    elements.answer1.placeholder = t.placeholder;
    elements.answer2.placeholder = t.placeholder;
    elements.answer3.placeholder = t.placeholder;
}

// Update active language button styling
function updateActiveLanguageButton() {
    elements.languageButtons.forEach(button => {
        if (button.getAttribute('data-lang') === currentLanguage) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    });
}

// Handle form submission
function handleSubmit() {
    const answers = {
        question1: elements.answer1.value.trim(),
        question2: elements.answer2.value.trim(),
        question3: elements.answer3.value.trim(),
        language: currentLanguage,
        submittedAt: new Date().toISOString()
    };
    
    // Validate that at least one answer is provided
    if (!answers.question1 && !answers.question2 && !answers.question3) {
        showMessage('error');
        return;
    }
    
    // In a real application, this would send data to a server
    // For now, we'll just save to localStorage and show success
    saveSubmission(answers);
    showMessage('success');
    
    // Clear the form after successful submission
    setTimeout(() => {
        clearForm();
    }, 2000);
}

// Show submit message
function showMessage(type) {
    const t = translations[currentLanguage];
    const message = type === 'success' ? t.submitSuccess : t.submitError;
    
    elements.submitMessage.textContent = message;
    elements.submitMessage.className = `submit-message ${type}`;
    elements.submitMessage.classList.remove('hidden');
    
    // Hide message after 5 seconds
    setTimeout(() => {
        elements.submitMessage.classList.add('hidden');
    }, 5000);
}

// Save submission to localStorage
function saveSubmission(answers) {
    const submissions = JSON.parse(localStorage.getItem('reflectionSubmissions') || '[]');
    submissions.push(answers);
    localStorage.setItem('reflectionSubmissions', JSON.stringify(submissions));
    
    // Clear individual answer storage after submission
    localStorage.removeItem('reflection_answer_1');
    localStorage.removeItem('reflection_answer_2');
    localStorage.removeItem('reflection_answer_3');
}

// Save individual answer to localStorage (for auto-save)
function saveAnswerToLocalStorage(questionNumber, answer) {
    localStorage.setItem(`reflection_answer_${questionNumber}`, answer);
}

// Load saved answers from localStorage
function loadSavedAnswers() {
    const answer1 = localStorage.getItem('reflection_answer_1');
    const answer2 = localStorage.getItem('reflection_answer_2');
    const answer3 = localStorage.getItem('reflection_answer_3');
    
    if (answer1) elements.answer1.value = answer1;
    if (answer2) elements.answer2.value = answer2;
    if (answer3) elements.answer3.value = answer3;
}

// Clear form
function clearForm() {
    elements.answer1.value = '';
    elements.answer2.value = '';
    elements.answer3.value = '';
    
    // Clear localStorage
    localStorage.removeItem('reflection_answer_1');
    localStorage.removeItem('reflection_answer_2');
    localStorage.removeItem('reflection_answer_3');
}

// Optional: Detect if user is about to leave with unsaved changes
window.addEventListener('beforeunload', (e) => {
    const hasUnsavedChanges = 
        elements.answer1.value.trim() || 
        elements.answer2.value.trim() || 
        elements.answer3.value.trim();
    
    if (hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = '';
    }
});
```


/* ========== public\styles.css ========== */
```css
/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f7fa;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.container {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    flex: 1;
}

/* Language Switcher */
.language-switcher {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-bottom: 20px;
}

.lang-btn {
    padding: 8px 16px;
    border: 2px solid #e0e0e0;
    background-color: white;
    color: #666;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.3s ease;
}

.lang-btn:hover {
    background-color: #f0f0f0;
    border-color: #d0d0d0;
}

.lang-btn.active {
    background-color: #4a90e2;
    color: white;
    border-color: #4a90e2;
}

/* Header */
header {
    text-align: center;
    margin-bottom: 40px;
    padding: 30px 0;
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

#page-title {
    font-size: 2.5em;
    color: #2c3e50;
    margin-bottom: 10px;
}

#welcome-message {
    font-size: 1.1em;
    color: #666;
}

/* Main Content */
main {
    background-color: white;
    border-radius: 12px;
    padding: 40px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.reflection-section h2 {
    color: #2c3e50;
    margin-bottom: 30px;
    font-size: 1.8em;
    text-align: center;
}

/* Question Blocks */
.question-block {
    margin-bottom: 30px;
}

.question-block h3 {
    color: #34495e;
    margin-bottom: 15px;
    font-size: 1.2em;
    font-weight: 600;
}

.answer-textarea {
    width: 100%;
    padding: 15px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 16px;
    font-family: inherit;
    resize: vertical;
    transition: border-color 0.3s ease;
}

.answer-textarea:focus {
    outline: none;
    border-color: #4a90e2;
}

.answer-textarea::placeholder {
    color: #999;
}

/* Submit Section */
.submit-section {
    text-align: center;
    margin-top: 40px;
}

.submit-button {
    background-color: #4a90e2;
    color: white;
    padding: 12px 40px;
    font-size: 16px;
    font-weight: 600;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.submit-button:hover {
    background-color: #357abd;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
}

.submit-button:active {
    transform: translateY(0);
}

.submit-message {
    margin-top: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    font-weight: 500;
}

.submit-message.success {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.submit-message.error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.hidden {
    display: none;
}

/* Footer */
footer {
    text-align: center;
    padding: 30px 0;
    margin-top: 40px;
    color: #666;
    font-size: 14px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .container {
        padding: 15px;
    }
    
    header {
        padding: 20px 15px;
    }
    
    #page-title {
        font-size: 2em;
    }
    
    main {
        padding: 25px;
    }
    
    .language-switcher {
        justify-content: center;
    }
    
    .submit-button {
        width: 100%;
        max-width: 300px;
    }
}

/* Animations */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.question-block {
    animation: fadeIn 0.5s ease-out;
}

.question-block:nth-child(2) {
    animation-delay: 0.1s;
}

.question-block:nth-child(3) {
    animation-delay: 0.2s;
}

.question-block:nth-child(4) {
    animation-delay: 0.3s;
}
```


/* ========== public\translations.js ========== */
```javascript
// Translation dictionary for multiple languages
const translations = {
    en: {
        // Page metadata
        pageTitle: "Course Reflection",
        
        // Header
        welcomeMessage: "Welcome to your course reflection page",
        
        // Main content
        reflectionHeading: "Share Your Experience",
        
        // Questions
        question1: "What did you enjoy most about the course?",
        question2: "What was the most challenging part?",
        question3: "What could be improved?",
        
        // Placeholders
        placeholder: "Type your answer here...",
        
        // Submit section
        submitButton: "Submit Reflection",
        submitSuccess: "Thank you! Your reflection has been submitted successfully.",
        submitError: "Sorry, there was an error submitting your reflection. Please try again.",
        
        // Footer
        footerText: "Â© 2025 Course Management Platform. All rights reserved."
    },
    
    fr: {
        // Page metadata
        pageTitle: "RÃ©flexion sur le cours",
        
        // Header
        welcomeMessage: "Bienvenue sur votre page de rÃ©flexion de cours",
        
        // Main content
        reflectionHeading: "Partagez votre expÃ©rience",
        
        // Questions
        question1: "Qu'avez-vous le plus apprÃ©ciÃ© dans ce cours ?",
        question2: "Quelle a Ã©tÃ© la partie la plus difficile ?",
        question3: "Qu'est-ce qui pourrait Ãªtre amÃ©liorÃ© ?",
        
        // Placeholders
        placeholder: "Tapez votre rÃ©ponse ici...",
        
        // Submit section
        submitButton: "Soumettre la rÃ©flexion",
        submitSuccess: "Merci ! Votre rÃ©flexion a Ã©tÃ© soumise avec succÃ¨s.",
        submitError: "DÃ©solÃ©, une erreur s'est produite lors de la soumission. Veuillez rÃ©essayer.",
        
        // Footer
        footerText: "Â© 2025 Plateforme de gestion de cours. Tous droits rÃ©servÃ©s."
    }
};

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
    module.exports = translations;
}
```


/* ========== README.md ========== */
```markdown

```


/* ========== server.js ========== */
```javascript
require("dotenv").config()
const validateEnvironment = require('./src/config/validateEnv');
validateEnvironment();
const app = require("./src/app")
const { sequelize } = require("./src/models")
const logger = require("./src/utils/logger")
const cron = require("cron")
const notificationService = require("./src/services/notificationService")

const PORT = process.env.PORT || 3000

// Test database connection and sync models
async function startServer() {
  try {
    // Test database connection
    await sequelize.authenticate()
    logger.info("Database connection established successfully.")

    // Sync database models (use migrations in production)
    if (process.env.NODE_ENV !== "production") {
      await sequelize.sync({ alter: true })
      logger.info("Database models synchronized.")
    }

    // Start cron job for reminders
    const reminderJob = new cron.CronJob(
      process.env.REMINDER_CRON_SCHEDULE || "0 9 * * MON",
      async () => {
        logger.info("Running scheduled reminder check...")
        try {
          await notificationService.checkAndSendReminders()
        } catch (error) {
          logger.error("Scheduled reminder check failed:", error)
        }
      },
      null,
      true,
      "America/New_York",
    )

    logger.info("Reminder cron job started")

    // Start the server
    const server = app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`)
      logger.info(`API Documentation available at http://localhost:${PORT}/api-docs`)
      logger.info(`Student Reflection Page available at http://localhost:${PORT}/reflection`)
    })

    // Graceful shutdown
    process.on("SIGTERM", async () => {
      logger.info("SIGTERM signal received: closing HTTP server")
      reminderJob.destroy()
      server.close(() => {
        logger.info("HTTP server closed")
      })
      await sequelize.close()
      process.exit(0)
    })

    process.on("SIGINT", async () => {
      logger.info("SIGINT signal received: closing HTTP server")
      reminderJob.destroy()
      server.close(() => {
        logger.info("HTTP server closed")
      })
      await sequelize.close()
      process.exit(0)
    })
  } catch (error) {
    logger.error("Unable to start server:", error)
    process.exit(1)
  }
}

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception:", error)
  process.exit(1)
})

// Handle unhandled promise rejections
process.on("unhandledRejection", (error) => {
  logger.error("Unhandled Rejection:", error)
  process.exit(1)
})

startServer()
```


/* ========== src\app.js ========== */
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const bodyParser = require('body-parser');
const rateLimit = require('express-rate-limit');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./config/swagger');
const routes = require('./routes');
const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');

const app = express();

// Security middleware
app.use(helmet());

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || '*',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000,
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: 'Too many requests from this IP, please try again later.'
});
app.use('/api/', limiter);

// Body parsing middleware
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '10mb' }));

// Add request ID for tracking
app.use((req, res, next) => {
  req.id = require('crypto').randomUUID();
  res.setHeader('X-Request-ID', req.id);
  next();
});

// Logging middleware
if (process.env.NODE_ENV !== 'test') {
  app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));
}

// API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    version: process.env.npm_package_version
  });
});

// API routes
app.use('/api', routes);

// Serve static files for student reflection page (in development)
if (process.env.NODE_ENV !== 'production') {
  app.use('/reflection', express.static('public'));
}

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: 'The requested resource was not found.',
    path: req.originalUrl
  });
});

// Global error handler
app.use(errorHandler);

module.exports = app;
```


/* ========== src\config\auth.js ========== */
```javascript
const jwt = require("jsonwebtoken")
const logger = require("../utils/logger")

const authConfig = {
  // JWT Configuration
  jwt: {
    secret: process.env.JWT_SECRET,
    refreshSecret: process.env.JWT_REFRESH_SECRET,
    expiresIn: process.env.JWT_EXPIRE || "7d",
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRE || "30d",
    issuer: process.env.APP_NAME || "Course Management Platform",
    audience: process.env.APP_URL || "http://localhost:3000",
  },

  // Password Configuration
  password: {
    minLength: 8,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSpecialChars: false,
    saltRounds: 12,
  },

  // Session Configuration
  session: {
    maxConcurrentSessions: 5,
    sessionTimeout: 24 * 60 * 60 * 1000, // 24 hours
    rememberMeTimeout: 30 * 24 * 60 * 60 * 1000, // 30 days
  },

  // Rate Limiting
  rateLimiting: {
    loginAttempts: {
      maxAttempts: 5,
      windowMs: 15 * 60 * 1000, // 15 minutes
      blockDuration: 30 * 60 * 1000, // 30 minutes
    },
    passwordReset: {
      maxAttempts: 3,
      windowMs: 60 * 60 * 1000, // 1 hour
      blockDuration: 2 * 60 * 60 * 1000, // 2 hours
    },
  },
}

// JWT Token Generation
const generateAccessToken = (payload) => {
  return jwt.sign(payload, authConfig.jwt.secret, {
    expiresIn: authConfig.jwt.expiresIn,
    issuer: authConfig.jwt.issuer,
    audience: authConfig.jwt.audience,
  })
}

const generateRefreshToken = (payload) => {
  return jwt.sign(payload, authConfig.jwt.refreshSecret, {
    expiresIn: authConfig.jwt.refreshExpiresIn,
    issuer: authConfig.jwt.issuer,
    audience: authConfig.jwt.audience,
  })
}

// JWT Token Verification
const verifyAccessToken = (token) => {
  try {
    return jwt.verify(token, authConfig.jwt.secret, {
      issuer: authConfig.jwt.issuer,
      audience: authConfig.jwt.audience,
    })
  } catch (error) {
    logger.error("Access token verification failed:", error)
    throw error
  }
}

const verifyRefreshToken = (token) => {
  try {
    return jwt.verify(token, authConfig.jwt.refreshSecret, {
      issuer: authConfig.jwt.issuer,
      audience: authConfig.jwt.audience,
    })
  } catch (error) {
    logger.error("Refresh token verification failed:", error)
    throw error
  }
}

// Token Blacklist (in production, use Redis)
const tokenBlacklist = new Set()

const blacklistToken = (token) => {
  tokenBlacklist.add(token)
}

const isTokenBlacklisted = (token) => {
  return tokenBlacklist.has(token)
}

module.exports = {
  authConfig,
  generateAccessToken,
  generateRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
  blacklistToken,
  isTokenBlacklisted,
}
```


/* ========== src\config\database.js ========== */
```javascript
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'course_management_db',
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: console.log,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    },
    define: {
      timestamps: true,
      underscored: true,
      paranoid: true
    }
  },
  test: {
    username: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: (process.env.DB_NAME || 'course_management_db') + '_test',
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: false,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    },
    define: {
      timestamps: true,
      underscored: true,
      paranoid: true
    }
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: false,
    pool: {
      max: 10,
      min: 2,
      acquire: 30000,
      idle: 10000
    },
    define: {
      timestamps: true,
      underscored: true,
      paranoid: true
    },
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    }
  }
};
```


/* ========== src\config\redis.js ========== */
```javascript
const Redis = require('redis');
const Bull = require('bull');
const logger = require('../utils/logger');

// Create Redis client
const redisClient = Redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD || undefined,
  retry_strategy: (options) => {
    if (options.error && options.error.code === 'ECONNREFUSED') {
      logger.error('Redis connection refused');
      return new Error('The server refused the connection');
    }
    if (options.total_retry_time > 1000 * 60 * 60) {
      logger.error('Redis retry time exhausted');
      return new Error('Retry time exhausted');
    }
    if (options.attempt > 10) {
      logger.error('Redis max retry attempts reached');
      return undefined;
    }
    // Reconnect after
    return Math.min(options.attempt * 100, 3000);
  }
});

// Redis event handlers
redisClient.on('connect', () => {
  logger.info('Redis client connected');
});

redisClient.on('error', (error) => {
  logger.error('Redis client error:', error);
});

redisClient.on('ready', () => {
  logger.info('Redis client ready');
});

// Connect to Redis
(async () => {
  try {
    await redisClient.connect();
  } catch (error) {
    logger.error('Failed to connect to Redis:', error);
  }
})();

// Create Bull queues
const notificationQueue = new Bull('notifications', {
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
    password: process.env.REDIS_PASSWORD || undefined
  },
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: false,
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  }
});

const reminderQueue = new Bull('reminders', {
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
    password: process.env.REDIS_PASSWORD || undefined
  },
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: false,
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  }
});

// Queue event handlers
notificationQueue.on('completed', (job) => {
  logger.info(`Notification job ${job.id} completed`);
});

notificationQueue.on('failed', (job, err) => {
  logger.error(`Notification job ${job.id} failed:`, err);
});

reminderQueue.on('completed', (job) => {
  logger.info(`Reminder job ${job.id} completed`);
});

reminderQueue.on('failed', (job, err) => {
  logger.error(`Reminder job ${job.id} failed:`, err);
});

module.exports = {
  redisClient,
  notificationQueue,
  reminderQueue
};
```


/* ========== src\config\swagger.js ========== */
```javascript
const swaggerJsdoc = require('swagger-jsdoc');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Course Management Platform API',
      version: '1.0.0',
      description: 'A comprehensive backend system for academic institutions to manage course allocations, track facilitator activities, and monitor student progress.',
      contact: {
        name: 'API Support',
        email: 'support@coursemanagement.edu'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      }
    },
    servers: [
      {
        url: 'http://localhost:3000/api',
        description: 'Development server'
      },
      {
        url: 'https://api.coursemanagement.edu/api',
        description: 'Production server'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT'
        }
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            email: { type: 'string', format: 'email' },
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            role: { type: 'string', enum: ['admin', 'manager', 'facilitator', 'student'] },
            isActive: { type: 'boolean' },
            createdAt: { type: 'string', format: 'date-time' },
            updatedAt: { type: 'string', format: 'date-time' }
          }
        },
        Module: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            code: { type: 'string' },
            name: { type: 'string' },
            description: { type: 'string' },
            credits: { type: 'integer' },
            level: { type: 'string', enum: ['100', '200', '300', '400', '500', '600'] },
            isActive: { type: 'boolean' }
          }
        },
        CourseOffering: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            moduleId: { type: 'integer' },
            classId: { type: 'integer' },
            cohortId: { type: 'integer' },
            facilitatorId: { type: 'integer' },
            modeId: { type: 'integer' },
            trimester: { type: 'integer', minimum: 1, maximum: 3 },
            intakePeriod: { type: 'string', enum: ['HT1', 'HT2', 'FT'] },
            startDate: { type: 'string', format: 'date' },
            endDate: { type: 'string', format: 'date' },
            maxStudents: { type: 'integer' },
            enrolledStudents: { type: 'integer' },
            status: { type: 'string', enum: ['planned', 'active', 'completed', 'cancelled'] }
          }
        },
        ActivityTracker: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            allocationId: { type: 'integer' },
            weekNumber: { type: 'integer', minimum: 1, maximum: 16 },
            attendance: { type: 'array', items: { type: 'boolean' } },
            formativeOneGrading: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            formativeTwoGrading: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            summativeGrading: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            courseModeration: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            intranetSync: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            gradeBookStatus: { type: 'string', enum: ['Done', 'Pending', 'Not Started'] },
            submittedAt: { type: 'string', format: 'date-time' },
            notes: { type: 'string' }
          }
        },
        PaginationResponse: {
          type: 'object',
          properties: {
            total: { 
              type: 'integer', 
              description: 'Total number of items' 
            },
            page: { 
              type: 'integer', 
              description: 'Current page number' 
            },
            limit: { 
              type: 'integer', 
              description: 'Number of items per page' 
            },
            pages: { 
              type: 'integer', 
              description: 'Total number of pages' 
            },
            hasNext: { 
              type: 'boolean', 
              description: 'Whether there is a next page' 
            },
            hasPrev: { 
              type: 'boolean', 
              description: 'Whether there is a previous page' 
            }
          },
          required: ['total', 'page', 'limit', 'pages', 'hasNext', 'hasPrev']
        },
        Error: {
          type: 'object',
          properties: {
            error: { type: 'string' },
            message: { type: 'string' },
            errors: { type: 'array', items: { type: 'object' } }
          }
        },
        LoginRequest: {
          type: 'object',
          required: ['email', 'password'],
          properties: {
            email: {
              type: 'string',
              format: 'email',
              description: "User's email address"
            },
            password: {
              type: 'string',
              description: "User's password"
            }
          }
        },
        RegisterRequest: {
          type: 'object',
          required: ['email', 'password', 'firstName', 'lastName', 'role'],
          properties: {
            email: {
              type: 'string',
              format: 'email',
              description: "User's email address"
            },
            password: {
              type: 'string',
              minLength: 8,
              description: "User's password (minimum 8 characters)"
            },
            firstName: {
              type: 'string',
              description: "User's first name"
            },
            lastName: {
              type: 'string',
              description: "User's last name"
            },
            role: {
              type: 'string',
              enum: ['admin', 'manager', 'facilitator', 'student'],
              description: "User's role in the system"
            },
            employeeId: {
              type: 'string',
              description: 'Employee ID (for managers and facilitators)'
            },
            department: {
              type: 'string',
              description: 'Department (for managers and facilitators)'
            },
            specialization: {
              type: 'string',
              description: 'Specialization (for facilitators)'
            },
            studentId: {
              type: 'string',
              description: 'Student ID (for students)'
            },
            cohortId: {
              type: 'integer',
              description: 'Cohort ID (for students)'
            }
          }
        },
        AuthResponse: {
          type: 'object',
          properties: {
            message: { type: 'string' },
            user: { '$ref': '#/components/schemas/User' },
            tokens: {
              type: 'object',
              properties: {
                accessToken: { type: 'string' },
                refreshToken: { type: 'string' }
              }
            }
          }
        },
        UserListResponse: {
          type: 'object',
          properties: {
            users: {
              type: 'array',
              items: { '$ref': '#/components/schemas/User' }
            },
            pagination: { '$ref': '#/components/schemas/PaginationResponse' }
          }
        },
        CourseOfferingListResponse: {
          type: 'object',
          properties: {
            courseOfferings: {
              type: 'array',
              items: { '$ref': '#/components/schemas/CourseOffering' }
            },
            pagination: { '$ref': '#/components/schemas/PaginationResponse' }
          }
        },
        ActivityTrackerListResponse: {
          type: 'object',
          properties: {
            activityLogs: {
              type: 'array',
              items: { '$ref': '#/components/schemas/ActivityTracker' }
            },
            pagination: { '$ref': '#/components/schemas/PaginationResponse' }
          }
        },
        ApiResponse: {
          type: 'object',
          properties: {
            message: { type: 'string' },
            data: { type: 'object' }
          }
        }
      }
    },
    security: [
      {
        bearerAuth: []
      }
    ]
  },
  apis: ['./src/routes/*.js']
};

const swaggerSpec = swaggerJsdoc(options);

module.exports = swaggerSpec;
```


/* ========== src\config\validateEnv.js ========== */
```javascript
const logger = require('../utils/logger');

const requiredEnvVars = [
  'JWT_SECRET',
  'JWT_REFRESH_SECRET'
];

const validateEnvironment = () => {
  const missing = [];
  
  requiredEnvVars.forEach(envVar => {
    if (!process.env[envVar]) {
      missing.push(envVar);
    }
  });
  
  if (missing.length > 0) {
    logger.error(`Missing required environment variables: ${missing.join(', ')}`);
    logger.error('Please check your .env file and ensure all required variables are set.');
    process.exit(1);
  }
  
  // Validate JWT secrets are not default values
  if (process.env.JWT_SECRET === 'your-secret-key' || process.env.JWT_SECRET?.length < 32) {
    logger.error('JWT_SECRET must be a strong secret (at least 32 characters)');
    process.exit(1);
  }
  
  logger.info('Environment validation passed');
};

module.exports = validateEnvironment;
```


/* ========== src\controllers\activityController.js ========== */
```javascript
const { validationResult } = require('express-validator');
const activityService = require('../services/activityService');
const notificationService = require('../services/notificationService');
const logger = require('../utils/logger');

const createActivityLog = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    // Get facilitator ID from authenticated user
    const facilitatorId = req.user.facilitator?.id;
    
    if (!facilitatorId) {
      return res.status(403).json({
        error: 'Access denied',
        message: 'Only facilitators can submit activity logs'
      });
    }

    const logData = req.body;
    const activityLog = await activityService.createActivityLog(logData, facilitatorId);
    
    // Notify managers if log is complete
    if (activityLog.isComplete()) {
      await notificationService.notifyActivitySubmission(activityLog.id);
    }
    
    logger.info(`Activity log created: ${activityLog.id}`);
    
    res.status(201).json({
      message: 'Activity log created successfully',
      activityLog
    });
  } catch (error) {
    logger.error('Create activity log error:', error);
    
    if (error.message.includes('already exists')) {
      return res.status(409).json({
        error: 'Duplicate activity log',
        message: error.message
      });
    }
    
    res.status(500).json({
      error: 'Failed to create activity log',
      message: error.message || 'Unable to create activity log'
    });
  }
};

const getAllActivityLogs = async (req, res) => {
  try {
    const filters = {
      allocationId: req.query.allocationId,
      weekNumber: req.query.weekNumber,
      facilitatorId: req.query.facilitatorId,
      status: req.query.status
    };

    // Remove undefined values
    Object.keys(filters).forEach(key => 
      filters[key] === undefined && delete filters[key]
    );

    const { page = 1, limit = 10 } = req.query;
    
    // Check access - facilitators can only see their own logs
    if (req.user.role === 'facilitator' && !filters.facilitatorId) {
      filters.facilitatorId = req.user.facilitator?.id;
    }
    
    const logs = await activityService.getAllActivityLogs(filters, page, limit);
    
    res.json(logs);
  } catch (error) {
    logger.error('Get activity logs error:', error);
    res.status(500).json({
      error: 'Failed to retrieve activity logs',
      message: 'Unable to fetch activity logs'
    });
  }
};

const getActivityLogById = async (req, res) => {
  try {
    const { id } = req.params;
    const activityLog = await activityService.getActivityLogById(id);
    
    if (!activityLog) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Activity log not found'
      });
    }
    
    // Check access - facilitators can only see their own logs
    if (req.user.role === 'facilitator') {
      const facilitatorId = req.user.facilitator?.id;
      if (activityLog.courseOffering.facilitatorId !== facilitatorId) {
        return res.status(403).json({
          error: 'Access denied',
          message: 'You can only view your own activity logs'
        });
      }
    }
    
    res.json({ activityLog });
  } catch (error) {
    logger.error('Get activity log error:', error);
    res.status(500).json({
      error: 'Failed to retrieve activity log',
      message: 'Unable to fetch activity log details'
    });
  }
};

const updateActivityLog = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const { id } = req.params;
    const updates = req.body;
    
    // Check ownership for facilitators
    if (req.user.role === 'facilitator') {
      const facilitatorId = req.user.facilitator?.id;
      const canUpdate = await activityService.checkFacilitatorOwnership(id, facilitatorId);
      
      if (!canUpdate) {
        return res.status(403).json({
          error: 'Access denied',
          message: 'You can only update your own activity logs'
        });
      }
    }
    
    const activityLog = await activityService.updateActivityLog(id, updates);
    
    if (!activityLog) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Activity log not found'
      });
    }
    
    // Notify managers if log is now complete
    if (activityLog.isComplete() && !activityLog.submittedAt) {
      await activityLog.markSubmitted();
      await notificationService.notifyActivitySubmission(activityLog.id);
    }
    
    logger.info(`Activity log updated: ${id}`);
    
    res.json({
      message: 'Activity log updated successfully',
      activityLog
    });
  } catch (error) {
    logger.error('Update activity log error:', error);
    res.status(500).json({
      error: 'Failed to update activity log',
      message: error.message || 'Unable to update activity log'
    });
  }
};

const deleteActivityLog = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Only managers can delete activity logs
    if (req.user.role !== 'manager' && req.user.role !== 'admin') {
      return res.status(403).json({
        error: 'Access denied',
        message: 'Only managers can delete activity logs'
      });
    }
    
    const result = await activityService.deleteActivityLog(id);
    
    if (!result) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Activity log not found'
      });
    }
    
    logger.info(`Activity log deleted: ${id}`);
    
    res.json({
      message: 'Activity log deleted successfully'
    });
  } catch (error) {
    logger.error('Delete activity log error:', error);
    res.status(500).json({
      error: 'Failed to delete activity log',
      message: 'Unable to delete activity log'
    });
  }
};

const getMyActivityLogs = async (req, res) => {
  try {
    // For facilitators to view their own logs
    const facilitatorId = req.user.facilitator?.id;
    
    if (!facilitatorId) {
      return res.status(403).json({
        error: 'Access denied',
        message: 'You must be a facilitator to view activity logs'
      });
    }
    
    const filters = {
      weekNumber: req.query.weekNumber,
      allocationId: req.query.allocationId
    };
    
    // Remove undefined values
    Object.keys(filters).forEach(key => 
      filters[key] === undefined && delete filters[key]
    );
    
    const logs = await activityService.getFacilitatorLogs(facilitatorId, filters);
    
    res.json({
      activityLogs: logs,
      total: logs.length
    });
  } catch (error) {
    logger.error('Get my activity logs error:', error);
    res.status(500).json({
      error: 'Failed to retrieve activity logs',
      message: 'Unable to fetch your activity logs'
    });
  }
};

const getWeeklySummary = async (req, res) => {
  try {
    const { weekNumber } = req.query;
    
    if (!weekNumber) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Week number is required'
      });
    }
    
    // Only managers can view weekly summaries
    if (req.user.role !== 'manager' && req.user.role !== 'admin') {
      return res.status(403).json({
        error: 'Access denied',
        message: 'Only managers can view weekly summaries'
      });
    }
    
    const summary = await activityService.getWeeklySummary(parseInt(weekNumber));
    
    res.json(summary);
  } catch (error) {
    logger.error('Get weekly summary error:', error);
    res.status(500).json({
      error: 'Failed to retrieve weekly summary',
      message: 'Unable to fetch weekly summary'
    });
  }
};

module.exports = {
  createActivityLog,
  getAllActivityLogs,
  getActivityLogById,
  updateActivityLog,
  deleteActivityLog,
  getMyActivityLogs,
  getWeeklySummary
};
```


/* ========== src\controllers\authController.js ========== */
```javascript
const jwt = require('jsonwebtoken');
const { validationResult } = require('express-validator');
const authService = require('../services/authService');
const logger = require('../utils/logger');

const generateTokens = (userId) => {
  const accessToken = jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    { expiresIn: process.env.JWT_EXPIRE || '7d' }
  );
  
  const refreshToken = jwt.sign(
    { id: userId },
    process.env.JWT_REFRESH_SECRET,
    { expiresIn: process.env.JWT_REFRESH_EXPIRE || '30d' }
  );
  
  return { accessToken, refreshToken };
};

const register = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const userData = req.body;
    const user = await authService.createUser(userData);
    
    const { accessToken, refreshToken } = generateTokens(user.id);
    
    logger.info(`New user registered: ${user.email}`);
    
    res.status(201).json({
      message: 'Registration successful',
      user: user.toJSON(),
      tokens: {
        accessToken,
        refreshToken
      }
    });
  } catch (error) {
    logger.error('Registration error:', error);
    
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({
        error: 'User already exists',
        message: 'An account with this email already exists'
      });
    }
    
    res.status(500).json({
      error: 'Registration failed',
      message: 'Unable to create user account'
    });
  }
};

const login = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const { email, password } = req.body;
    const user = await authService.authenticateUser(email, password);
    
    if (!user) {
      return res.status(401).json({
        error: 'Authentication failed',
        message: 'Invalid email or password'
      });
    }

    const { accessToken, refreshToken } = generateTokens(user.id);
    
    logger.info(`User logged in: ${user.email}`);
    
    res.json({
      message: 'Login successful',
      user: user.toJSON(),
      tokens: {
        accessToken,
        refreshToken
      }
    });
  } catch (error) {
    logger.error('Login error:', error);
    res.status(500).json({
      error: 'Login failed',
      message: 'Unable to process login request'
    });
  }
};

const refreshToken = async (req, res) => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      return res.status(400).json({
        error: 'Missing token',
        message: 'Refresh token is required'
      });
    }

    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
    const user = await authService.getUserById(decoded.id);
    
    if (!user) {
      throw new Error('User not found');
    }

    const tokens = generateTokens(user.id);
    
    res.json({
      message: 'Token refreshed successfully',
      tokens
    });
  } catch (error) {
    logger.error('Token refresh error:', error);
    
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: 'Invalid token',
        message: 'The refresh token is invalid or expired'
      });
    }
    
    res.status(500).json({
      error: 'Token refresh failed',
      message: 'Unable to refresh access token'
    });
  }
};

const logout = async (req, res) => {
  try {
    // In a production environment, you might want to:
    // 1. Add the token to a blacklist in Redis
    // 2. Clear any server-side sessions
    // 3. Log the logout event
    
    logger.info(`User logged out: ${req.user.email}`);
    
    res.json({
      message: 'Logout successful'
    });
  } catch (error) {
    logger.error('Logout error:', error);
    res.status(500).json({
      error: 'Logout failed',
      message: 'Unable to process logout request'
    });
  }
};

const getProfile = async (req, res) => {
  try {
    const user = await authService.getUserProfile(req.user.id);
    
    res.json({
      user: user.toJSON()
    });
  } catch (error) {
    logger.error('Get profile error:', error);
    res.status(500).json({
      error: 'Failed to retrieve profile',
      message: 'Unable to fetch user profile'
    });
  }
};

const updateProfile = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const updates = req.body;
    const user = await authService.updateUserProfile(req.user.id, updates);
    
    res.json({
      message: 'Profile updated successfully',
      user: user.toJSON()
    });
  } catch (error) {
    logger.error('Update profile error:', error);
    res.status(500).json({
      error: 'Update failed',
      message: 'Unable to update profile'
    });
  }
};

const changePassword = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const { currentPassword, newPassword } = req.body;
    const success = await authService.changePassword(
      req.user.id,
      currentPassword,
      newPassword
    );
    
    if (!success) {
      return res.status(401).json({
        error: 'Password change failed',
        message: 'Current password is incorrect'
      });
    }
    
    res.json({
      message: 'Password changed successfully'
    });
  } catch (error) {
    logger.error('Change password error:', error);
    res.status(500).json({
      error: 'Password change failed',
      message: 'Unable to change password'
    });
  }
};

module.exports = {
  register,
  login,
  refreshToken,
  logout,
  getProfile,
  updateProfile,
  changePassword
};
```


/* ========== src\controllers\courseController.js ========== */
```javascript
const { validationResult } = require('express-validator');
const courseService = require('../services/courseService');
const logger = require('../utils/logger');

const createCourseOffering = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const courseData = req.body;
    const courseOffering = await courseService.createCourseOffering(courseData);
    
    logger.info(`Course offering created: ${courseOffering.id}`);
    
    res.status(201).json({
      message: 'Course offering created successfully',
      courseOffering
    });
  } catch (error) {
    logger.error('Create course offering error:', error);
    
    if (error.message.includes('already exists')) {
      return res.status(409).json({
        error: 'Duplicate course offering',
        message: error.message
      });
    }
    
    res.status(500).json({
      error: 'Failed to create course offering',
      message: error.message || 'Unable to create course offering'
    });
  }
};

const getAllCourseOfferings = async (req, res) => {
  try {
    const filters = {
      trimester: req.query.trimester,
      cohortId: req.query.cohortId,
      facilitatorId: req.query.facilitatorId,
      intakePeriod: req.query.intakePeriod,
      modeId: req.query.modeId,
      status: req.query.status
    };

    // Remove undefined values
    Object.keys(filters).forEach(key => 
      filters[key] === undefined && delete filters[key]
    );

    const { page = 1, limit = 10 } = req.query;
    const offerings = await courseService.getAllCourseOfferings(filters, page, limit);
    
    res.json(offerings);
  } catch (error) {
    logger.error('Get course offerings error:', error);
    res.status(500).json({
      error: 'Failed to retrieve course offerings',
      message: 'Unable to fetch course offerings'
    });
  }
};

const getCourseOfferingById = async (req, res) => {
  try {
    const { id } = req.params;
    const courseOffering = await courseService.getCourseOfferingById(id);
    
    if (!courseOffering) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Course offering not found'
      });
    }
    
    res.json({ courseOffering });
  } catch (error) {
    logger.error('Get course offering error:', error);
    res.status(500).json({
      error: 'Failed to retrieve course offering',
      message: 'Unable to fetch course offering details'
    });
  }
};

const updateCourseOffering = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const { id } = req.params;
    const updates = req.body;
    
    const courseOffering = await courseService.updateCourseOffering(id, updates);
    
    if (!courseOffering) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Course offering not found'
      });
    }
    
    logger.info(`Course offering updated: ${id}`);
    
    res.json({
      message: 'Course offering updated successfully',
      courseOffering
    });
  } catch (error) {
    logger.error('Update course offering error:', error);
    res.status(500).json({
      error: 'Failed to update course offering',
      message: error.message || 'Unable to update course offering'
    });
  }
};

const deleteCourseOffering = async (req, res) => {
  try {
    const { id } = req.params;
    const result = await courseService.deleteCourseOffering(id);
    
    if (!result) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Course offering not found'
      });
    }
    
    logger.info(`Course offering deleted: ${id}`);
    
    res.json({
      message: 'Course offering deleted successfully'
    });
  } catch (error) {
    logger.error('Delete course offering error:', error);
    res.status(500).json({
      error: 'Failed to delete course offering',
      message: 'Unable to delete course offering'
    });
  }
};

const assignFacilitator = async (req, res) => {
  try {
    const { id } = req.params;
    const { facilitatorId } = req.body;
    
    if (!facilitatorId) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Facilitator ID is required'
      });
    }
    
    const courseOffering = await courseService.assignFacilitator(id, facilitatorId);
    
    logger.info(`Facilitator ${facilitatorId} assigned to course offering ${id}`);
    
    res.json({
      message: 'Facilitator assigned successfully',
      courseOffering
    });
  } catch (error) {
    logger.error('Assign facilitator error:', error);
    res.status(500).json({
      error: 'Failed to assign facilitator',
      message: error.message || 'Unable to assign facilitator'
    });
  }
};

const getMyAssignedCourses = async (req, res) => {
  try {
    // For facilitators to view their assigned courses
    const facilitatorId = req.user.facilitator?.id;
    
    if (!facilitatorId) {
      return res.status(403).json({
        error: 'Access denied',
        message: 'You must be a facilitator to view assigned courses'
      });
    }
    
    const courses = await courseService.getFacilitatorCourses(facilitatorId);
    
    res.json({
      courses,
      total: courses.length
    });
  } catch (error) {
    logger.error('Get assigned courses error:', error);
    res.status(500).json({
      error: 'Failed to retrieve assigned courses',
      message: 'Unable to fetch your assigned courses'
    });
  }
};

const createModule = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        errors: errors.array()
      });
    }

    const moduleData = req.body;
    const module = await courseService.createModule(moduleData);
    
    logger.info(`Module created: ${module.code}`);
    
    res.status(201).json({
      message: 'Module created successfully',
      module
    });
  } catch (error) {
    logger.error('Create module error:', error);
    
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({
        error: 'Duplicate module',
        message: 'A module with this code already exists'
      });
    }
    
    res.status(500).json({
      error: 'Failed to create module',
      message: 'Unable to create module'
    });
  }
};

const getAllModules = async (req, res) => {
  try {
    const modules = await courseService.getAllModules();
    res.json({ modules });
  } catch (error) {
    logger.error('Get modules error:', error);
    res.status(500).json({
      error: 'Failed to retrieve modules',
      message: 'Unable to fetch modules'
    });
  }
};

module.exports = {
  createCourseOffering,
  getAllCourseOfferings,
  getCourseOfferingById,
  updateCourseOffering,
  deleteCourseOffering,
  assignFacilitator,
  getMyAssignedCourses,
  createModule,
  getAllModules
};
```


/* ========== src\controllers\userController.js ========== */
```javascript
const { validationResult } = require("express-validator")
const { User, Manager, Facilitator, Student, Cohort } = require("../models")
const { formatPaginationResponse } = require("../utils/helpers")
const logger = require("../utils/logger")

const getAllUsers = async (req, res) => {
  try {
    const { page = 1, limit = 10, role, isActive, search } = req.query
    const offset = (page - 1) * limit
    const where = {}

    // Apply filters
    if (role) where.role = role
    if (isActive !== undefined) where.isActive = isActive === "true"
    if (search) {
      const { Op } = require("sequelize")
      where[Op.or] = [
        { firstName: { [Op.like]: `%${search}%` } },
        { lastName: { [Op.like]: `%${search}%` } },
        { email: { [Op.like]: `%${search}%` } },
      ]
    }

    const { count, rows } = await User.findAndCountAll({
      where,
      attributes: { exclude: ["password", "resetPasswordToken", "resetPasswordExpires"] },
      include: [
        { model: Manager, as: "manager", required: false },
        { model: Facilitator, as: "facilitator", required: false },
        {
          model: Student,
          as: "student",
          required: false,
          include: [{ model: Cohort, as: "cohort" }],
        },
      ],
      limit: Number.parseInt(limit),
      offset,
      order: [["createdAt", "DESC"]],
    })

    res.json({
      users: rows,
      pagination: formatPaginationResponse(count, page, limit),
    })
  } catch (error) {
    logger.error("Get all users error:", error)
    res.status(500).json({
      error: "Failed to fetch users",
      message: "Unable to retrieve users list",
    })
  }
}

const getUserById = async (req, res) => {
  try {
    const { id } = req.params

    const user = await User.findByPk(id, {
      attributes: { exclude: ["password", "resetPasswordToken", "resetPasswordExpires"] },
      include: [
        { model: Manager, as: "manager" },
        { model: Facilitator, as: "facilitator" },
        {
          model: Student,
          as: "student",
          include: [{ model: Cohort, as: "cohort" }],
        },
      ],
    })

    if (!user) {
      return res.status(404).json({
        error: "User not found",
        message: "The requested user does not exist",
      })
    }

    res.json({ user })
  } catch (error) {
    logger.error("Get user by ID error:", error)
    res.status(500).json({
      error: "Failed to fetch user",
      message: "Unable to retrieve user details",
    })
  }
}

const updateUser = async (req, res) => {
  try {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: "Validation failed",
        errors: errors.array(),
      })
    }

    const { id } = req.params
    const updates = req.body

    const user = await User.findByPk(id)
    if (!user) {
      return res.status(404).json({
        error: "User not found",
        message: "The requested user does not exist",
      })
    }

    // Only allow certain fields to be updated
    const allowedFields = ["firstName", "lastName", "isActive"]
    const filteredUpdates = {}

    allowedFields.forEach((field) => {
      if (updates[field] !== undefined) {
        filteredUpdates[field] = updates[field]
      }
    })

    await user.update(filteredUpdates)

    const updatedUser = await User.findByPk(id, {
      attributes: { exclude: ["password", "resetPasswordToken", "resetPasswordExpires"] },
      include: [
        { model: Manager, as: "manager" },
        { model: Facilitator, as: "facilitator" },
        { model: Student, as: "student" },
      ],
    })

    logger.info(`User updated: ${id}`)

    res.json({
      message: "User updated successfully",
      user: updatedUser,
    })
  } catch (error) {
    logger.error("Update user error:", error)
    res.status(500).json({
      error: "Failed to update user",
      message: "Unable to update user information",
    })
  }
}

const deactivateUser = async (req, res) => {
  try {
    const { id } = req.params

    const user = await User.findByPk(id)
    if (!user) {
      return res.status(404).json({
        error: "User not found",
        message: "The requested user does not exist",
      })
    }

    await user.update({ isActive: false })

    logger.info(`User deactivated: ${id}`)

    res.json({
      message: "User deactivated successfully",
    })
  } catch (error) {
    logger.error("Deactivate user error:", error)
    res.status(500).json({
      error: "Failed to deactivate user",
      message: "Unable to deactivate user account",
    })
  }
}

const deleteUser = async (req, res) => {
  try {
    const { id } = req.params

    const user = await User.findByPk(id)
    if (!user) {
      return res.status(404).json({
        error: "User not found",
        message: "The requested user does not exist",
      })
    }

    // Soft delete
    await user.destroy()

    logger.info(`User deleted: ${id}`)

    res.json({
      message: "User deleted successfully",
    })
  } catch (error) {
    logger.error("Delete user error:", error)
    res.status(500).json({
      error: "Failed to delete user",
      message: "Unable to delete user account",
    })
  }
}

const getUserStats = async (req, res) => {
  try {
    const stats = await User.findAll({
      attributes: ["role", [require("sequelize").fn("COUNT", require("sequelize").col("id")), "count"]],
      where: { isActive: true },
      group: ["role"],
    })

    const totalUsers = await User.count({ where: { isActive: true } })
    const inactiveUsers = await User.count({ where: { isActive: false } })

    res.json({
      totalUsers,
      inactiveUsers,
      roleDistribution: stats.reduce((acc, stat) => {
        acc[stat.role] = Number.parseInt(stat.dataValues.count)
        return acc
      }, {}),
    })
  } catch (error) {
    logger.error("Get user stats error:", error)
    res.status(500).json({
      error: "Failed to fetch user statistics",
      message: "Unable to retrieve user statistics",
    })
  }
}

module.exports = {
  getAllUsers,
  getUserById,
  updateUser,
  deactivateUser,
  deleteUser,
  getUserStats,
}
```


/* ========== src\middleware\auth.js ========== */
```javascript
const jwt = require('jsonwebtoken');
const { User } = require('../models');
const logger = require('../utils/logger');

// Update the authenticate function:
const authenticate = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        error: 'Authentication required',
        message: 'Please provide a valid authentication token'
      });
    }

    // Validate JWT secret is configured
    if (!process.env.JWT_SECRET) {
      logger.error('JWT_SECRET not configured');
      return res.status(500).json({ 
        error: 'Server configuration error',
        message: 'Authentication system not properly configured'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    const user = await User.findOne({
      where: {
        id: decoded.id,
        isActive: true
      }
    });

    if (!user) {
      throw new Error('User not found or inactive');
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save({ silent: true });

    req.user = user;
    req.token = token;
    
    next();
  } catch (error) {
    logger.error('Authentication error:', error);
    
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        error: 'Invalid token',
        message: 'The provided token is invalid'
      });
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: 'Token expired',
        message: 'Your session has expired. Please login again'
      });
    }
    
    res.status(401).json({
      error: 'Authentication failed',
      message: 'Unable to authenticate the request'
    });
  }
};


const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        error: 'Authentication required',
        message: 'Please login to access this resource'
      });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        error: 'Access denied',
        message: `This resource requires one of the following roles: ${roles.join(', ')}`
      });
    }

    next();
  };
};

const optionalAuth = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (token) {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);
      
      if (user && user.isActive) {
        req.user = user;
        req.token = token;
      }
    }
  } catch (error) {
    // Silent fail - user remains unauthenticated
    logger.debug('Optional auth failed:', error.message);
  }
  
  next();
};

module.exports = {
  authenticate,
  authorize,
  optionalAuth
};
```


/* ========== src\middleware\errorHandler.js ========== */
```javascript
const logger = require('../utils/logger');

const errorHandler = (err, req, res, next) => {
  // Log error with request context
  logger.error('Error:', {
    requestId: req.id,
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    user: req.user?.id,
    body: req.method === 'POST' || req.method === 'PUT' ? req.body : undefined
  });

  // Default error
  let error = {
    error: 'Internal Server Error',
    message: 'An unexpected error occurred'
  };
  let statusCode = 500;

  // Sequelize validation error
  if (err.name === 'SequelizeValidationError') {
    statusCode = 400;
    error = {
      error: 'Validation Error',
      message: 'Invalid data provided',
      errors: err.errors.map(e => ({
        field: e.path,
        message: e.message
      }))
    };
  }

  // Sequelize unique constraint error
  if (err.name === 'SequelizeUniqueConstraintError') {
    statusCode = 409;
    error = {
      error: 'Duplicate Entry',
      message: 'A record with this value already exists',
      fields: err.errors.map(e => e.path)
    };
  }

  // Sequelize foreign key constraint error
  if (err.name === 'SequelizeForeignKeyConstraintError') {
    statusCode = 400;
    error = {
      error: 'Invalid Reference',
      message: 'Referenced record does not exist'
    };
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    statusCode = 401;
    error = {
      error: 'Invalid Token',
      message: 'The provided token is invalid'
    };
  }

  if (err.name === 'TokenExpiredError') {
    statusCode = 401;
    error = {
      error: 'Token Expired',
      message: 'Your session has expired'
    };
  }

  // Custom application errors
  if (err.statusCode) {
    statusCode = err.statusCode;
    error = {
      error: err.error || 'Error',
      message: err.message
    };
  }

  // Send error response
  res.status(statusCode).json(error);
};

module.exports = errorHandler;
```


/* ========== src\middleware\roleCheck.js ========== */
```javascript
const { hasRole } = require('../utils/helpers');
const logger = require('../utils/logger');

/**
 * Role-based access control middleware
 * @param {...string} allowedRoles - Roles that are allowed to access the resource
 * @returns {Function} Express middleware function
 */
const requireRole = (...allowedRoles) => {
  return (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({
          error: 'Authentication required',
          message: 'Please login to access this resource'
        });
      }

      if (!hasRole(req.user, allowedRoles)) {
        logger.warn(`Access denied for user ${req.user.id} with role ${req.user.role}`, {
          userId: req.user.id,
          userRole: req.user.role,
          requiredRoles: allowedRoles,
          resource: req.originalUrl
        });

        return res.status(403).json({
          error: 'Access denied',
          message: `This resource requires one of the following roles: ${allowedRoles.join(', ')}`
        });
      }

      next();
    } catch (error) {
      logger.error('Role check error:', error);
      res.status(500).json({
        error: 'Authorization failed',
        message: 'Unable to verify user permissions'
      });
    }
  };
};

/**
 * Check if user owns the resource or has admin/manager role
 * @param {Function} getResourceOwnerId - Function to get the owner ID of the resource
 * @returns {Function} Express middleware function
 */
const requireOwnershipOrRole = (getResourceOwnerId, ...allowedRoles) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({
          error: 'Authentication required',
          message: 'Please login to access this resource'
        });
      }

      // Check if user has allowed role
      if (hasRole(req.user, allowedRoles)) {
        return next();
      }

      // Check ownership
      const resourceOwnerId = await getResourceOwnerId(req);
      
      if (req.user.id === resourceOwnerId) {
        return next();
      }

      // Check role-specific ownership (e.g., facilitator owns their courses)
      if (req.user.role === 'facilitator' && req.user.facilitator) {
        if (req.user.facilitator.id === resourceOwnerId) {
          return next();
        }
      }

      return res.status(403).json({
        error: 'Access denied',
        message: 'You can only access your own resources'
      });
    } catch (error) {
      logger.error('Ownership check error:', error);
      res.status(500).json({
        error: 'Authorization failed',
        message: 'Unable to verify resource ownership'
      });
    }
  };
};

/**
 * Dynamic role check based on request context
 * @param {Function} getRolesForContext - Function that returns allowed roles based on context
 * @returns {Function} Express middleware function
 */
const requireDynamicRole = (getRolesForContext) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({
          error: 'Authentication required',
          message: 'Please login to access this resource'
        });
      }

      const allowedRoles = await getRolesForContext(req);
      
      if (!hasRole(req.user, allowedRoles)) {
        return res.status(403).json({
          error: 'Access denied',
          message: `Insufficient permissions for this operation`
        });
      }

      next();
    } catch (error) {
      logger.error('Dynamic role check error:', error);
      res.status(500).json({
        error: 'Authorization failed',
        message: 'Unable to verify permissions'
      });
    }
  };
};

/**
 * Check if user can manage a specific facilitator
 * @param {Function} getFacilitatorId - Function to get facilitator ID from request
 * @returns {Function} Express middleware function
 */
const canManageFacilitator = (getFacilitatorId) => {
  return async (req, res, next) => {
    try {
      if (!req.user) {
        return res.status(401).json({
          error: 'Authentication required'
        });
      }

      // Admins can manage anyone
      if (req.user.role === 'admin') {
        return next();
      }

      // Managers can manage facilitators in their department
      if (req.user.role === 'manager' && req.user.manager) {
        const facilitatorId = await getFacilitatorId(req);
        const { Facilitator, User } = require('../models');
        
        const facilitator = await Facilitator.findByPk(facilitatorId, {
          include: [{ model: User, as: 'user' }]
        });

        if (facilitator && facilitator.department === req.user.manager.department) {
          return next();
        }
      }

      // Facilitators can only manage themselves
      if (req.user.role === 'facilitator' && req.user.facilitator) {
        const facilitatorId = await getFacilitatorId(req);
        if (req.user.facilitator.id === facilitatorId) {
          return next();
        }
      }

      return res.status(403).json({
        error: 'Access denied',
        message: 'You cannot manage this facilitator'
      });
    } catch (error) {
      logger.error('Facilitator management check error:', error);
      res.status(500).json({
        error: 'Authorization failed'
      });
    }
  };
};

module.exports = {
  requireRole,
  requireOwnershipOrRole,
  requireDynamicRole,
  canManageFacilitator
};
```


/* ========== src\middleware\validation.js ========== */
```javascript
const { body, param, query, validationResult } = require('express-validator');

// Validation rules
const validationRules = {
  // Auth validations
  register: [
    body('email')
      .isEmail()
      .normalizeEmail()
      .withMessage('Please provide a valid email'),
    body('password')
      .isLength({ min: 8 })
      .withMessage('Password must be at least 8 characters long')
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number'),
    body('firstName')
      .trim()
      .notEmpty()
      .withMessage('First name is required')
      .isLength({ min: 2, max: 100 })
      .withMessage('First name must be between 2 and 100 characters'),
    body('lastName')
      .trim()
      .notEmpty()
      .withMessage('Last name is required')
      .isLength({ min: 2, max: 100 })
      .withMessage('Last name must be between 2 and 100 characters'),
    body('role')
      .isIn(['admin', 'manager', 'facilitator', 'student'])
      .withMessage('Invalid role')
  ],

  login: [
    body('email')
      .isEmail()
      .normalizeEmail()
      .withMessage('Please provide a valid email'),
    body('password')
      .notEmpty()
      .withMessage('Password is required')
  ],

  // Course validations
  createCourseOffering: [
    body('moduleId')
      .isInt({ min: 1 })
      .withMessage('Valid module ID is required'),
    body('classId')
      .isInt({ min: 1 })
      .withMessage('Valid class ID is required'),
    body('cohortId')
      .isInt({ min: 1 })
      .withMessage('Valid cohort ID is required'),
    body('facilitatorId')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Valid facilitator ID is required'),
    body('modeId')
      .isInt({ min: 1 })
      .withMessage('Valid mode ID is required'),
    body('trimester')
      .isInt({ min: 1, max: 3 })
      .withMessage('Trimester must be between 1 and 3'),
    body('intakePeriod')
      .isIn(['HT1', 'HT2', 'FT'])
      .withMessage('Invalid intake period'),
    body('startDate')
      .isISO8601()
      .withMessage('Valid start date is required'),
    body('endDate')
      .isISO8601()
      .withMessage('Valid end date is required')
      .custom((value, { req }) => {
        if (new Date(value) <= new Date(req.body.startDate)) {
          throw new Error('End date must be after start date');
        }
        return true;
      }),
    body('maxStudents')
      .optional()
      .isInt({ min: 1, max: 500 })
      .withMessage('Max students must be between 1 and 500')
  ],

  updateCourseOffering: [
    param('id')
      .isInt({ min: 1 })
      .withMessage('Valid course offering ID is required'),
    body('facilitatorId')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Valid facilitator ID is required'),
    body('status')
      .optional()
      .isIn(['planned', 'active', 'completed', 'cancelled'])
      .withMessage('Invalid status'),
    body('maxStudents')
      .optional()
      .isInt({ min: 1, max: 500 })
      .withMessage('Max students must be between 1 and 500')
  ],

  // Activity validations
  createActivityLog: [
    body('allocationId')
      .isInt({ min: 1 })
      .withMessage('Valid allocation ID is required'),
    body('weekNumber')
      .isInt({ min: 1, max: 16 })
      .withMessage('Week number must be between 1 and 16'),
    body('attendance')
      .isArray()
      .withMessage('Attendance must be an array')
      .custom((value) => {
        if (!value.every(item => typeof item === 'boolean')) {
          throw new Error('All attendance values must be boolean');
        }
        return true;
      }),
    body('formativeOneGrading')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid grading status'),
    body('formativeTwoGrading')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid grading status'),
    body('summativeGrading')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid grading status'),
    body('courseModeration')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid moderation status'),
    body('intranetSync')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid sync status'),
    body('gradeBookStatus')
      .optional()
      .isIn(['Done', 'Pending', 'Not Started'])
      .withMessage('Invalid gradebook status')
  ],

  // Query validations
  paginationQuery: [
    query('page')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Page must be a positive integer'),
    query('limit')
      .optional()
      .isInt({ min: 1, max: 100 })
      .withMessage('Limit must be between 1 and 100')
  ],

  courseFilters: [
    query('trimester')
      .optional()
      .isInt({ min: 1, max: 3 })
      .withMessage('Trimester must be between 1 and 3'),
    query('cohortId')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Valid cohort ID is required'),
    query('facilitatorId')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Valid facilitator ID is required'),
    query('intakePeriod')
      .optional()
      .isIn(['HT1', 'HT2', 'FT'])
      .withMessage('Invalid intake period'),
    query('modeId')
      .optional()
      .isInt({ min: 1 })
      .withMessage('Valid mode ID is required'),
    query('status')
      .optional()
      .isIn(['planned', 'active', 'completed', 'cancelled'])
      .withMessage('Invalid status')
  ],

  // ID parameter validation
  idParam: [
    param('id')
      .isInt({ min: 1 })
      .withMessage('Valid ID is required')
  ]
};

// Validation error handler
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      error: 'Validation failed',
      errors: errors.array()
    });
  }
  next();
};

// Combine validation rules with error handler
const validate = (validationName) => {
  if (!validationRules[validationName]) {
    throw new Error(`Validation rules for ${validationName} not found`);
  }
  return [...validationRules[validationName], handleValidationErrors];
};

module.exports = {
  validate,
  validationRules,
  handleValidationErrors
};
```


/* ========== src\models\ActivityTracker.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const ActivityTracker = sequelize.define('ActivityTracker', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    allocationId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'allocation_id',
      references: {
        model: 'course_offerings',
        key: 'id'
      }
    },
    weekNumber: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'week_number',
      validate: {
        min: 1,
        max: 16
      }
    },
    attendance: {
      type: DataTypes.JSON,
      allowNull: false,
      defaultValue: [],
      validate: {
        isValidAttendanceArray(value) {
          if (!Array.isArray(value)) {
            throw new Error('Attendance must be an array');
          }
          if (value.some(item => typeof item !== 'boolean')) {
            throw new Error('All attendance values must be boolean');
          }
        }
      }
    },
    formativeOneGrading: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'formative_one_grading'
    },
    formativeTwoGrading: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'formative_two_grading'
    },
    summativeGrading: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'summative_grading'
    },
    courseModeration: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'course_moderation'
    },
    intranetSync: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'intranet_sync'
    },
    gradeBookStatus: {
      type: DataTypes.ENUM('Done', 'Pending', 'Not Started'),
      defaultValue: 'Not Started',
      field: 'grade_book_status'
    },
    submittedAt: {
      type: DataTypes.DATE,
      field: 'submitted_at'
    },
    lastReminderSent: {
      type: DataTypes.DATE,
      field: 'last_reminder_sent'
    },
    reminderCount: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
      field: 'reminder_count'
    },
    notes: {
      type: DataTypes.TEXT
    }
  }, {
    tableName: 'activity_trackers',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        name: 'activity_unique_idx',
        unique: true,
        fields: ['allocation_id', 'week_number']
      },
      {
        fields: ['week_number']
      },
      {
        fields: ['submitted_at']
      },
      // Add composite index for common filtering queries
      {
        name: 'activity_status_week_idx',
        fields: ['week_number', 'submitted_at']
      },
      // Add index for facilitator queries
      {
        name: 'activity_allocation_week_idx',
        fields: ['allocation_id', 'week_number', 'submitted_at']
      }
    ]
  });

  // Instance methods
  ActivityTracker.prototype.isComplete = function () {
    return this.formativeOneGrading === 'Done' &&
      this.formativeTwoGrading === 'Done' &&
      this.summativeGrading === 'Done' &&
      this.courseModeration === 'Done' &&
      this.intranetSync === 'Done' &&
      this.gradeBookStatus === 'Done' &&
      this.attendance.length > 0;
  };

  ActivityTracker.prototype.getCompletionPercentage = function () {
    const statuses = [
      this.formativeOneGrading,
      this.formativeTwoGrading,
      this.summativeGrading,
      this.courseModeration,
      this.intranetSync,
      this.gradeBookStatus
    ];

    const completed = statuses.filter(status => status === 'Done').length;
    const hasAttendance = this.attendance.length > 0 ? 1 : 0;

    return Math.round(((completed + hasAttendance) / 7) * 100);
  };

  ActivityTracker.prototype.markSubmitted = async function () {
    this.submittedAt = new Date();
    await this.save();
  };

  ActivityTracker.prototype.incrementReminderCount = async function () {
    this.reminderCount += 1;
    this.lastReminderSent = new Date();
    await this.save();
  };

  return ActivityTracker;
};
```


/* ========== src\models\Class.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Class = sequelize.define('Class', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    name: {
      type: DataTypes.STRING(50),
      allowNull: false,
      unique: true
    },
    year: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        min: 2020,
        max: 2100
      }
    },
    section: {
      type: DataTypes.STRING(10),
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    }
  }, {
    tableName: 'classes',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['name']
      },
      {
        fields: ['year']
      }
    ]
  });

  return Class;
};
```


/* ========== src\models\Cohort.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Cohort = sequelize.define('Cohort', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    name: {
      type: DataTypes.STRING(100),
      allowNull: false,
      unique: true
    },
    code: {
      type: DataTypes.STRING(20),
      allowNull: false,
      unique: true
    },
    startDate: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'start_date'
    },
    endDate: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'end_date'
    },
    program: {
      type: DataTypes.STRING(100),
      allowNull: false
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
      field: 'is_active'
    }
  }, {
    tableName: 'cohorts',
    timestamps: true,
    underscored: true,
    paranoid: true,
    validate: {
      endDateAfterStartDate() {
        if (this.endDate <= this.startDate) {
          throw new Error('End date must be after start date');
        }
      }
    }
  });

  return Cohort;
};
```


/* ========== src\models\CourseOffering.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const CourseOffering = sequelize.define('CourseOffering', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    moduleId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'module_id',
      references: {
        model: 'modules',
        key: 'id'
      }
    },
    classId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'class_id',
      references: {
        model: 'classes',
        key: 'id'
      }
    },
    cohortId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'cohort_id',
      references: {
        model: 'cohorts',
        key: 'id'
      }
    },
    facilitatorId: {
      type: DataTypes.INTEGER,
      allowNull: true,
      field: 'facilitator_id',
      references: {
        model: 'facilitators',
        key: 'id'
      }
    },
    modeId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'mode_id',
      references: {
        model: 'modes',
        key: 'id'
      }
    },
    trimester: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        min: 1,
        max: 3
      }
    },
    intakePeriod: {
      type: DataTypes.ENUM('HT1', 'HT2', 'FT'),
      allowNull: false,
      field: 'intake_period'
    },
    startDate: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'start_date'
    },
    endDate: {
      type: DataTypes.DATE,
      allowNull: false,
      field: 'end_date'
    },
    maxStudents: {
      type: DataTypes.INTEGER,
      defaultValue: 30,
      field: 'max_students',
      validate: {
        min: 1
      }
    },
    enrolledStudents: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
      field: 'enrolled_students',
      validate: {
        min: 0
      }
    },
    status: {
      type: DataTypes.ENUM('planned', 'active', 'completed', 'cancelled'),
      defaultValue: 'planned'
    },
    notes: {
      type: DataTypes.TEXT
    }
  }, {
    tableName: 'course_offerings',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        // Shortened index name to avoid MySQL length limit
        name: 'course_unique_idx',
        unique: true,
        fields: ['module_id', 'class_id', 'cohort_id', 'trimester', 'intake_period']
      },
      {
        fields: ['facilitator_id']
      },
      {
        fields: ['status']
      },
      {
        fields: ['trimester', 'intake_period']
      }
    ],
    validate: {
      endDateAfterStartDate() {
        if (this.endDate <= this.startDate) {
          throw new Error('End date must be after start date');
        }
      },
      enrollmentNotExceedMax() {
        if (this.enrolledStudents > this.maxStudents) {
          throw new Error('Enrolled students cannot exceed maximum students');
        }
      }
    }
  });

  // Instance methods
  CourseOffering.prototype.isAvailable = function() {
    return this.enrolledStudents < this.maxStudents && this.status === 'active';
  };

  CourseOffering.prototype.getRemainingSlots = function() {
    return this.maxStudents - this.enrolledStudents;
  };

  CourseOffering.prototype.incrementEnrollment = async function() {
    if (this.enrolledStudents >= this.maxStudents) {
      throw new Error('Course is full');
    }
    this.enrolledStudents += 1;
    await this.save();
  };

  CourseOffering.prototype.decrementEnrollment = async function() {
    if (this.enrolledStudents <= 0) {
      throw new Error('No students enrolled');
    }
    this.enrolledStudents -= 1;
    await this.save();
  };

  return CourseOffering;
};
```


/* ========== src\models\Facilitator.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Facilitator = sequelize.define('Facilitator', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    userId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      unique: true,
      field: 'user_id',
      references: {
        model: 'users',
        key: 'id'
      }
    },
    employeeId: {
      type: DataTypes.STRING(50),
      unique: true,
      field: 'employee_id'
    },
    department: {
      type: DataTypes.STRING(100)
    },
    specialization: {
      type: DataTypes.STRING(255)
    },
    qualifications: {
      type: DataTypes.TEXT
    },
    experienceYears: {
      type: DataTypes.INTEGER,
      field: 'experience_years',
      validate: {
        min: 0
      }
    },
    maxCourseLoad: {
      type: DataTypes.INTEGER,
      defaultValue: 4,
      field: 'max_course_load',
      validate: {
        min: 1,
        max: 10
      }
    },
    currentCourseLoad: {
      type: DataTypes.INTEGER,
      defaultValue: 0,
      field: 'current_course_load',
      validate: {
        min: 0
      }
    },
    isAvailable: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
      field: 'is_available'
    }
  }, {
    tableName: 'facilitators',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['user_id']
      },
      {
        unique: true,
        fields: ['employee_id']
      }
    ]
  });

  // Instance methods
  Facilitator.prototype.canTakeMoreCourses = function() {
    return this.currentCourseLoad < this.maxCourseLoad && this.isAvailable;
  };

  Facilitator.prototype.getRemainingCapacity = function() {
    return this.maxCourseLoad - this.currentCourseLoad;
  };

  return Facilitator;
};
```


/* ========== src\models\index.js ========== */
```javascript
const { Sequelize } = require('sequelize');
const config = require('../config/database');
const logger = require('../utils/logger');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env];

const sequelize = new Sequelize(
  dbConfig.database,
  dbConfig.username,
  dbConfig.password,
  {
    ...dbConfig,
    logging: (msg) => logger.debug(msg)
  }
);

// Import models
const User = require('./User')(sequelize);
const Manager = require('./Manager')(sequelize);
const Facilitator = require('./Facilitator')(sequelize);
const Student = require('./Student')(sequelize);
const Module = require('./Module')(sequelize);
const Cohort = require('./Cohort')(sequelize);
const Class = require('./Class')(sequelize);
const Mode = require('./Mode')(sequelize);
const CourseOffering = require('./CourseOffering')(sequelize);
const ActivityTracker = require('./ActivityTracker')(sequelize);

// Define associations
const models = {
  User,
  Manager,
  Facilitator,
  Student,
  Module,
  Cohort,
  Class,
  Mode,
  CourseOffering,
  ActivityTracker
};

// User associations
User.hasOne(Manager, { foreignKey: 'user_id', as: 'manager' });
User.hasOne(Facilitator, { foreignKey: 'user_id', as: 'facilitator' });
User.hasOne(Student, { foreignKey: 'user_id', as: 'student' });

Manager.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
Facilitator.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
Student.belongsTo(User, { foreignKey: 'user_id', as: 'user' });

// Course Offering associations
CourseOffering.belongsTo(Module, { foreignKey: 'module_id', as: 'module' });
CourseOffering.belongsTo(Class, { foreignKey: 'class_id', as: 'class' });
CourseOffering.belongsTo(Cohort, { foreignKey: 'cohort_id', as: 'cohort' });
CourseOffering.belongsTo(Facilitator, { foreignKey: 'facilitator_id', as: 'facilitator' });
CourseOffering.belongsTo(Mode, { foreignKey: 'mode_id', as: 'mode' });

Module.hasMany(CourseOffering, { foreignKey: 'module_id', as: 'courseOfferings' });
Class.hasMany(CourseOffering, { foreignKey: 'class_id', as: 'courseOfferings' });
Cohort.hasMany(CourseOffering, { foreignKey: 'cohort_id', as: 'courseOfferings' });
Facilitator.hasMany(CourseOffering, { foreignKey: 'facilitator_id', as: 'courseOfferings' });
Mode.hasMany(CourseOffering, { foreignKey: 'mode_id', as: 'courseOfferings' });

// Activity Tracker associations
ActivityTracker.belongsTo(CourseOffering, { foreignKey: 'allocation_id', as: 'courseOffering' });
CourseOffering.hasMany(ActivityTracker, { foreignKey: 'allocation_id', as: 'activityLogs' });

// Student-Cohort association
Student.belongsTo(Cohort, { foreignKey: 'cohort_id', as: 'cohort' });
Cohort.hasMany(Student, { foreignKey: 'cohort_id', as: 'students' });

// Execute association methods if they exist
Object.keys(models).forEach(modelName => {
  if (models[modelName].associate) {
    models[modelName].associate(models);
  }
});

module.exports = {
  sequelize,
  Sequelize,
  ...models
};
```


/* ========== src\models\Manager.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Manager = sequelize.define('Manager', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    userId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      unique: true,
      field: 'user_id',
      references: {
        model: 'users',
        key: 'id'
      }
    },
    employeeId: {
      type: DataTypes.STRING(50),
      unique: true,
      field: 'employee_id'
    },
    department: {
      type: DataTypes.STRING(100)
    },
    managementLevel: {
      type: DataTypes.ENUM('senior', 'middle', 'junior'),
      defaultValue: 'junior',
      field: 'management_level'
    },
    canApproveAllocations: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
      field: 'can_approve_allocations'
    }
  }, {
    tableName: 'managers',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['user_id']
      },
      {
        unique: true,
        fields: ['employee_id']
      }
    ]
  });

  return Manager;
};
```


/* ========== src\models\Mode.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Mode = sequelize.define('Mode', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    name: {
      type: DataTypes.STRING(50),
      allowNull: false,
      unique: true,
      validate: {
        notEmpty: true,
        len: [2, 50]
      }
    },
    description: {
      type: DataTypes.TEXT,
      validate: {
        len: [0, 500]
      }
    },
    requiresPhysicalPresence: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
      field: 'requires_physical_presence'
    }
  }, {
    tableName: 'modes',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['name']
      }
    ]
  });

  // Instance methods
  Mode.prototype.isOnline = function() {
    return this.name.toLowerCase().includes('online') && !this.requiresPhysicalPresence;
  };

  Mode.prototype.isInPerson = function() {
    return this.name.toLowerCase().includes('person') && this.requiresPhysicalPresence;
  };

  Mode.prototype.isHybrid = function() {
    return this.name.toLowerCase().includes('hybrid');
  };

  return Mode;
};
```


/* ========== src\models\Module.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Module = sequelize.define('Module', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    code: {
      type: DataTypes.STRING(20),
      allowNull: false,
      unique: true
    },
    name: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    credits: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 3,
      validate: {
        min: 1,
        max: 10
      }
    },
    level: {
      type: DataTypes.ENUM('100', '200', '300', '400', '500', '600'),
      allowNull: false
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
      field: 'is_active'
    }
  }, {
    tableName: 'modules',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['code']
      },
      {
        fields: ['level']
      }
    ]
  });

  return Module;
};
```


/* ========== src\models\Student.js ========== */
```javascript
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const Student = sequelize.define('Student', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    userId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      unique: true,
      field: 'user_id',
      references: {
        model: 'users',
        key: 'id'
      }
    },
    studentId: {
      type: DataTypes.STRING(50),
      allowNull: false,
      unique: true,
      field: 'student_id'
    },
    cohortId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      field: 'cohort_id',
      references: {
        model: 'cohorts',
        key: 'id'
      }
    },
    enrollmentDate: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
      field: 'enrollment_date'
    },
    expectedGraduation: {
      type: DataTypes.DATE,
      field: 'expected_graduation'
    },
    status: {
      type: DataTypes.ENUM('active', 'inactive', 'graduated', 'withdrawn'),
      defaultValue: 'active'
    },
    gpa: {
      type: DataTypes.DECIMAL(3, 2),
      validate: {
        min: 0.0,
        max: 4.0
      }
    }
  }, {
    tableName: 'students',
    timestamps: true,
    underscored: true,
    paranoid: true,
    indexes: [
      {
        unique: true,
        fields: ['user_id']
      },
      {
        unique: true,
        fields: ['student_id']
      },
      {
        fields: ['cohort_id']
      },
      {
        fields: ['status']
      }
    ]
  });

  return Student;
};
```


/* ========== src\models\User.js ========== */
```javascript
const { DataTypes } = require('sequelize');
const bcrypt = require('bcrypt');

module.exports = (sequelize) => {
  const User = sequelize.define('User', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    email: {
      type: DataTypes.STRING(255),
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    password: {
      type: DataTypes.STRING(255),
      allowNull: false
    },
    firstName: {
      type: DataTypes.STRING(100),
      allowNull: false,
      field: 'first_name'
    },
    lastName: {
      type: DataTypes.STRING(100),
      allowNull: false,
      field: 'last_name'
    },
    role: {
      type: DataTypes.ENUM('admin', 'manager', 'facilitator', 'student'),
      allowNull: false,
      defaultValue: 'student'
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
      field: 'is_active'
    },
    lastLogin: {
      type: DataTypes.DATE,
      field: 'last_login'
    },
    resetPasswordToken: {
      type: DataTypes.STRING(255),
      field: 'reset_password_token'
    },
    resetPasswordExpires: {
      type: DataTypes.DATE,
      field: 'reset_password_expires'
    }
  }, {
    tableName: 'users',
    timestamps: true,
    underscored: true,
    paranoid: true,
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          user.password = await bcrypt.hash(user.password, 10);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          user.password = await bcrypt.hash(user.password, 10);
        }
      }
    }
  });

  // Instance methods
  User.prototype.validatePassword = async function(password) {
    return bcrypt.compare(password, this.password);
  };

  User.prototype.toJSON = function() {
    const values = { ...this.get() };
    delete values.password;
    delete values.resetPasswordToken;
    delete values.resetPasswordExpires;
    delete values.deletedAt;
    return values;
  };

  User.prototype.getFullName = function() {
    return `${this.firstName} ${this.lastName}`;
  };

  return User;
};
```


/* ========== src\routes\activityRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const activityController = require('../controllers/activityController');
const { authenticate, authorize } = require('../middleware/auth');
const { validate } = require('../middleware/validation');

/**
 * @swagger
 * /activities:
 *   post:
 *     summary: Create a new activity log
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/ActivityTracker'
 *     responses:
 *       201:
 *         description: Activity log created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Facilitators only
 *       409:
 *         description: Activity log already exists for this week
 */
router.post('/', 
  authenticate, 
  authorize('facilitator'), 
  validate('createActivityLog'), 
  activityController.createActivityLog
);

/**
 * @swagger
 * /activities:
 *   get:
 *     summary: Get all activity logs with filters
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: allocationId
 *         schema:
 *           type: integer
 *       - in: query
 *         name: weekNumber
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 16
 *       - in: query
 *         name: facilitatorId
 *         schema:
 *           type: integer
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [complete, incomplete]
 *     responses:
 *       200:
 *         description: List of activity logs with pagination
 *       401:
 *         description: Unauthorized
 */
router.get('/', 
  authenticate, 
  validate('paginationQuery'), 
  activityController.getAllActivityLogs
);

/**
 * @swagger
 * /activities/my-logs:
 *   get:
 *     summary: Get facilitator's own activity logs
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: weekNumber
 *         schema:
 *           type: integer
 *       - in: query
 *         name: allocationId
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: List of facilitator's activity logs
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Facilitators only
 */
router.get('/my-logs', 
  authenticate, 
  authorize('facilitator'), 
  activityController.getMyActivityLogs
);

/**
 * @swagger
 * /activities/summary:
 *   get:
 *     summary: Get weekly summary of activity logs
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: weekNumber
 *         required: true
 *         schema:
 *           type: integer
 *           minimum: 1
 *           maximum: 16
 *     responses:
 *       200:
 *         description: Weekly summary of submissions
 *       400:
 *         description: Week number is required
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 */
router.get('/summary', 
  authenticate, 
  authorize('manager', 'admin'), 
  activityController.getWeeklySummary
);

/**
 * @swagger
 * /activities/{id}:
 *   get:
 *     summary: Get activity log by ID
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Activity log details
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Can only view own logs
 *       404:
 *         description: Activity log not found
 */
router.get('/:id', 
  authenticate, 
  validate('idParam'), 
  activityController.getActivityLogById
);

/**
 * @swagger
 * /activities/{id}:
 *   put:
 *     summary: Update activity log
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               attendance:
 *                 type: array
 *                 items:
 *                   type: boolean
 *               formativeOneGrading:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               formativeTwoGrading:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               summativeGrading:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               courseModeration:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               intranetSync:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               gradeBookStatus:
 *                 type: string
 *                 enum: [Done, Pending, Not Started]
 *               notes:
 *                 type: string
 *     responses:
 *       200:
 *         description: Activity log updated successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Can only update own logs
 *       404:
 *         description: Activity log not found
 */
router.put('/:id', 
  authenticate, 
  validate('idParam'), 
  activityController.updateActivityLog
);

/**
 * @swagger
 * /activities/{id}:
 *   delete:
 *     summary: Delete activity log
 *     tags: [Activities]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Activity log deleted successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 *       404:
 *         description: Activity log not found
 */
router.delete('/:id', 
  authenticate, 
  authorize('manager', 'admin'), 
  validate('idParam'), 
  activityController.deleteActivityLog
);

module.exports = router;
```


/* ========== src\routes\authRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticate } = require('../middleware/auth');
const { validate } = require('../middleware/validation');

/**
 * @swagger
 * /auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Authentication]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *               - firstName
 *               - lastName
 *               - role
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *                 minLength: 8
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               role:
 *                 type: string
 *                 enum: [admin, manager, facilitator, student]
 *     responses:
 *       201:
 *         description: User registered successfully
 *       400:
 *         description: Validation error
 *       409:
 *         description: User already exists
 */
router.post('/register', validate('register'), authController.register);

/**
 * @swagger
 * /auth/login:
 *   post:
 *     summary: Login user
 *     tags: [Authentication]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               password:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login successful
 *       401:
 *         description: Invalid credentials
 */
router.post('/login', validate('login'), authController.login);

/**
 * @swagger
 * /auth/refresh:
 *   post:
 *     summary: Refresh access token
 *     tags: [Authentication]
 *     security: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - refreshToken
 *             properties:
 *               refreshToken:
 *                 type: string
 *     responses:
 *       200:
 *         description: Token refreshed successfully
 *       401:
 *         description: Invalid refresh token
 */
router.post('/refresh', authController.refreshToken);

/**
 * @swagger
 * /auth/logout:
 *   post:
 *     summary: Logout user
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Logout successful
 *       401:
 *         description: Unauthorized
 */
router.post('/logout', authenticate, authController.logout);

/**
 * @swagger
 * /auth/profile:
 *   get:
 *     summary: Get user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User profile retrieved
 *       401:
 *         description: Unauthorized
 */
router.get('/profile', authenticate, authController.getProfile);

/**
 * @swagger
 * /auth/profile:
 *   put:
 *     summary: Update user profile
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *     responses:
 *       200:
 *         description: Profile updated successfully
 *       401:
 *         description: Unauthorized
 */
router.put('/profile', authenticate, authController.updateProfile);

/**
 * @swagger
 * /auth/change-password:
 *   post:
 *     summary: Change user password
 *     tags: [Authentication]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - currentPassword
 *               - newPassword
 *             properties:
 *               currentPassword:
 *                 type: string
 *               newPassword:
 *                 type: string
 *                 minLength: 8
 *     responses:
 *       200:
 *         description: Password changed successfully
 *       401:
 *         description: Current password incorrect
 */
router.post('/change-password', authenticate, authController.changePassword);

module.exports = router;
```


/* ========== src\routes\classRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const { authenticate, authorize } = require('../middleware/auth');
const { validate } = require('../middleware/validation');
const { Class } = require('../models');
const logger = require('../utils/logger');

/**
 * @swagger
 * /classes:
 *   get:
 *     summary: Get all classes
 *     tags: [Classes]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of classes
 *       401:
 *         description: Unauthorized
 */
router.get('/', authenticate, async (req, res) => {
  try {
    const classes = await Class.findAll({
      order: [['year', 'DESC'], ['section', 'ASC']]
    });
    res.json({ classes });
  } catch (error) {
    logger.error('Get classes error:', error);
    res.status(500).json({ error: 'Failed to fetch classes' });
  }
});

/**
 * @swagger
 * /classes:
 *   post:
 *     summary: Create a new class
 *     tags: [Classes]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - year
 *               - section
 *             properties:
 *               name:
 *                 type: string
 *               year:
 *                 type: integer
 *               section:
 *                 type: string
 *               description:
 *                 type: string
 *     responses:
 *       201:
 *         description: Class created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 */
router.post('/', authenticate, authorize('manager', 'admin'), async (req, res) => {
  try {
    const classEntity = await Class.create(req.body);
    logger.info(`Class created: ${classEntity.name}`);
    res.status(201).json({ 
      message: 'Class created successfully', 
      class: classEntity 
    });
  } catch (error) {
    logger.error('Create class error:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({
        error: 'Duplicate class',
        message: 'A class with this name already exists'
      });
    }
    res.status(500).json({ error: 'Failed to create class' });
  }
});

module.exports = router;
```


/* ========== src\routes\cohortRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const { authenticate, authorize } = require('../middleware/auth');
const { validate } = require('../middleware/validation');
const { Cohort, Student, User } = require('../models');
const logger = require('../utils/logger');

/**
 * @swagger
 * /cohorts:
 *   get:
 *     summary: Get all cohorts
 *     tags: [Cohorts]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of cohorts
 *       401:
 *         description: Unauthorized
 */
router.get('/', authenticate, async (req, res) => {
  try {
    const cohorts = await Cohort.findAll({
      where: { isActive: true },
      include: [{ 
        model: Student, 
        as: 'students',
        attributes: ['id'],
        include: [{
          model: User,
          as: 'user',
          attributes: ['firstName', 'lastName', 'email']
        }]
      }],
      order: [['startDate', 'DESC']]
    });

    // Add student count to each cohort
    const cohortsWithCount = cohorts.map(cohort => ({
      ...cohort.toJSON(),
      studentCount: cohort.students.length
    }));

    res.json({ cohorts: cohortsWithCount });
  } catch (error) {
    logger.error('Get cohorts error:', error);
    res.status(500).json({ error: 'Failed to fetch cohorts' });
  }
});

/**
 * @swagger
 * /cohorts:
 *   post:
 *     summary: Create a new cohort
 *     tags: [Cohorts]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - code
 *               - startDate
 *               - endDate
 *               - program
 *             properties:
 *               name:
 *                 type: string
 *               code:
 *                 type: string
 *               startDate:
 *                 type: string
 *                 format: date
 *               endDate:
 *                 type: string
 *                 format: date
 *               program:
 *                 type: string
 *     responses:
 *       201:
 *         description: Cohort created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 */
router.post('/', authenticate, authorize('manager', 'admin'), async (req, res) => {
  try {
    const cohort = await Cohort.create(req.body);
    logger.info(`Cohort created: ${cohort.code}`);
    res.status(201).json({ 
      message: 'Cohort created successfully', 
      cohort 
    });
  } catch (error) {
    logger.error('Create cohort error:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({
        error: 'Duplicate cohort',
        message: 'A cohort with this code already exists'
      });
    }
    res.status(500).json({ error: 'Failed to create cohort' });
  }
});

/**
 * @swagger
 * /cohorts/{id}:
 *   get:
 *     summary: Get cohort by ID
 *     tags: [Cohorts]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Cohort details
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Cohort not found
 */
router.get('/:id', authenticate, validate('idParam'), async (req, res) => {
  try {
    const { id } = req.params;
    const cohort = await Cohort.findByPk(id, {
      include: [{ 
        model: Student, 
        as: 'students',
        include: [{
          model: User,
          as: 'user',
          attributes: ['firstName', 'lastName', 'email']
        }]
      }]
    });

    if (!cohort) {
      return res.status(404).json({
        error: 'Not found',
        message: 'Cohort not found'
      });
    }

    res.json({ cohort });
  } catch (error) {
    logger.error('Get cohort error:', error);
    res.status(500).json({ error: 'Failed to fetch cohort' });
  }
});

module.exports = router;
```


/* ========== src\routes\courseRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const courseController = require('../controllers/courseController');
const { authenticate, authorize } = require('../middleware/auth');
const { validate } = require('../middleware/validation');

/**
 * @swagger
 * /courses/modules:
 *   post:
 *     summary: Create a new module
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - code
 *               - name
 *               - credits
 *               - level
 *             properties:
 *               code:
 *                 type: string
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               credits:
 *                 type: integer
 *               level:
 *                 type: string
 *                 enum: ['100', '200', '300', '400', '500', '600']
 *     responses:
 *       201:
 *         description: Module created successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 */
router.post('/modules', authenticate, authorize('manager', 'admin'), courseController.createModule);

/**
 * @swagger
 * /courses/modules:
 *   get:
 *     summary: Get all modules
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of modules
 *       401:
 *         description: Unauthorized
 */
router.get('/modules', authenticate, courseController.getAllModules);

/**
 * @swagger
 * /courses:
 *   post:
 *     summary: Create a new course offering
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/CourseOffering'
 *     responses:
 *       201:
 *         description: Course offering created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 *       409:
 *         description: Course offering already exists
 */
router.post('/', 
  authenticate, 
  authorize('manager', 'admin'), 
  validate('createCourseOffering'), 
  courseController.createCourseOffering
);

/**
 * @swagger
 * /courses:
 *   get:
 *     summary: Get all course offerings with filters
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: trimester
 *         schema:
 *           type: integer
 *           enum: [1, 2, 3]
 *       - in: query
 *         name: cohortId
 *         schema:
 *           type: integer
 *       - in: query
 *         name: facilitatorId
 *         schema:
 *           type: integer
 *       - in: query
 *         name: intakePeriod
 *         schema:
 *           type: string
 *           enum: [HT1, HT2, FT]
 *       - in: query
 *         name: modeId
 *         schema:
 *           type: integer
 *       - in: query
 *         name: status
 *         schema:
 *           type: string
 *           enum: [planned, active, completed, cancelled]
 *     responses:
 *       200:
 *         description: List of course offerings with pagination
 *       401:
 *         description: Unauthorized
 */
router.get('/', 
  authenticate, 
  validate('courseFilters'), 
  validate('paginationQuery'), 
  courseController.getAllCourseOfferings
);

/**
 * @swagger
 * /courses/my-courses:
 *   get:
 *     summary: Get facilitator's assigned courses
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of assigned courses
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Facilitators only
 */
router.get('/my-courses', 
  authenticate, 
  authorize('facilitator'), 
  courseController.getMyAssignedCourses
);

/**
 * @swagger
 * /courses/{id}:
 *   get:
 *     summary: Get course offering by ID
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Course offering details
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Course offering not found
 */
router.get('/:id', 
  authenticate, 
  validate('idParam'), 
  courseController.getCourseOfferingById
);

/**
 * @swagger
 * /courses/{id}:
 *   put:
 *     summary: Update course offering
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               facilitatorId:
 *                 type: integer
 *               status:
 *                 type: string
 *                 enum: [planned, active, completed, cancelled]
 *               maxStudents:
 *                 type: integer
 *     responses:
 *       200:
 *         description: Course offering updated successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 *       404:
 *         description: Course offering not found
 */
router.put('/:id', 
  authenticate, 
  authorize('manager', 'admin'), 
  validate('updateCourseOffering'), 
  courseController.updateCourseOffering
);

/**
 * @swagger
 * /courses/{id}:
 *   delete:
 *     summary: Delete course offering
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Course offering deleted successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 *       404:
 *         description: Course offering not found
 */
router.delete('/:id', 
  authenticate, 
  authorize('manager', 'admin'), 
  validate('idParam'), 
  courseController.deleteCourseOffering
);

/**
 * @swagger
 * /courses/{id}/assign-facilitator:
 *   post:
 *     summary: Assign facilitator to course offering
 *     tags: [Courses]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - facilitatorId
 *             properties:
 *               facilitatorId:
 *                 type: integer
 *     responses:
 *       200:
 *         description: Facilitator assigned successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 *       404:
 *         description: Course offering not found
 */
router.post('/:id/assign-facilitator', 
  authenticate, 
  authorize('manager', 'admin'), 
  validate('idParam'),
  courseController.assignFacilitator
);

module.exports = router;
```


/* ========== src\routes\index.js ========== */
```javascript
const express = require('express');
const router = express.Router();

// Import route modules
const authRoutes = require('./authRoutes');
const courseRoutes = require('./courseRoutes');
const activityRoutes = require('./activityRoutes');
const userRoutes = require('./userRoutes');
const classRoutes = require('./classRoutes');
const cohortRoutes = require('./cohortRoutes');
const modeRoutes = require('./modeRoutes');

// Mount routes
router.use('/auth', authRoutes);
router.use('/courses', courseRoutes);
router.use('/activities', activityRoutes);
router.use('/users', userRoutes);
router.use('/classes', classRoutes);
router.use('/cohorts', cohortRoutes);
router.use('/modes', modeRoutes);

// Base route
router.get('/', (req, res) => {
  res.json({
    message: 'Course Management Platform API',
    version: '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    endpoints: {
      auth: '/api/auth',
      courses: '/api/courses',
      activities: '/api/activities',
      users: '/api/users',
      classes: '/api/classes',
      cohorts: '/api/cohorts',
      modes: '/api/modes',
      documentation: '/api-docs'
    },
    features: {
      authentication: 'JWT-based with role management',
      database: 'MySQL with Sequelize ORM',
      notifications: 'Redis-backed queue system',
      i18n: 'Student reflection page with language switching'
    }
  });
});

// Database seeding endpoint (development only)
if (process.env.NODE_ENV !== 'production') {
  router.post('/seed', async (req, res) => {
    try {
      const seedDatabase = require('../utils/seedDatabase');
      await seedDatabase();
      res.json({ 
        message: 'Database seeded successfully',
        note: 'Check server logs for login credentials'
      });
    } catch (error) {
      console.error('Seed error:', error);
      res.status(500).json({ 
        error: 'Failed to seed database',
        message: error.message
      });
    }
  });
}

// Health monitoring endpoints
router.get('/monitoring/redis', async (req, res) => {
  try {
    const { redisClient } = require('../config/redis');
    // Simple ping test
    await redisClient.ping();
    res.json({ 
      status: 'OK', 
      service: 'Redis',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(503).json({ 
      status: 'ERROR', 
      service: 'Redis',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

router.get('/monitoring/mysql', async (req, res) => {
  try {
    const { sequelize } = require('../models');
    await sequelize.authenticate();
    res.json({ 
      status: 'OK', 
      service: 'MySQL',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(503).json({ 
      status: 'ERROR', 
      service: 'MySQL',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

router.get('/monitoring/status', async (req, res) => {
  const status = {
    api: 'OK',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    services: {}
  };

  // Check Redis
  try {
    const { redisClient } = require('../config/redis');
    await redisClient.ping();
    status.services.redis = 'OK';
  } catch (error) {
    status.services.redis = 'ERROR';
  }

  // Check MySQL
  try {
    const { sequelize } = require('../models');
    await sequelize.authenticate();
    status.services.mysql = 'OK';
  } catch (error) {
    status.services.mysql = 'ERROR';
  }

  const hasErrors = Object.values(status.services).includes('ERROR');
  res.status(hasErrors ? 503 : 200).json(status);
});

module.exports = router;
```


/* ========== src\routes\modeRoutes.js ========== */
```javascript
const express = require('express');
const router = express.Router();
const { authenticate, authorize } = require('../middleware/auth');
const { validate } = require('../middleware/validation');
const { Mode } = require('../models');
const logger = require('../utils/logger');

/**
 * @swagger
 * /modes:
 *   get:
 *     summary: Get all delivery modes
 *     tags: [Modes]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of delivery modes
 *       401:
 *         description: Unauthorized
 */
router.get('/', authenticate, async (req, res) => {
  try {
    const modes = await Mode.findAll({
      order: [['name', 'ASC']]
    });
    res.json({ modes });
  } catch (error) {
    logger.error('Get modes error:', error);
    res.status(500).json({ error: 'Failed to fetch modes' });
  }
});

/**
 * @swagger
 * /modes:
 *   post:
 *     summary: Create a new delivery mode
 *     tags: [Modes]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *               description:
 *                 type: string
 *               requiresPhysicalPresence:
 *                 type: boolean
 *     responses:
 *       201:
 *         description: Mode created successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers only
 */
router.post('/', authenticate, authorize('manager', 'admin'), async (req, res) => {
  try {
    const mode = await Mode.create(req.body);
    logger.info(`Mode created: ${mode.name}`);
    res.status(201).json({ 
      message: 'Mode created successfully', 
      mode 
    });
  } catch (error) {
    logger.error('Create mode error:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({
        error: 'Duplicate mode',
        message: 'A mode with this name already exists'
      });
    }
    res.status(500).json({ error: 'Failed to create mode' });
  }
});

module.exports = router;
```


/* ========== src\routes\userRoutes.js ========== */
```javascript
const express = require("express")
const router = express.Router()
const userController = require("../controllers/userController")
const { authenticate, authorize } = require("../middleware/auth")
const { requireRole } = require("../middleware/roleCheck")
const { validate } = require("../middleware/validation")

/**
 * @swagger
 * /users:
 *   get:
 *     summary: Get all users with filtering and pagination
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *       - in: query
 *         name: role
 *         schema:
 *           type: string
 *           enum: [admin, manager, facilitator, student]
 *       - in: query
 *         name: isActive
 *         schema:
 *           type: boolean
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of users with pagination
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/User'
 *                 pagination:
 *                   $ref: '#/components/schemas/PaginationResponse'
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin only
 */
router.get("/", authenticate, requireRole("admin"), validate("paginationQuery"), userController.getAllUsers)

/**
 * @swagger
 * /users/stats:
 *   get:
 *     summary: Get user statistics
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User statistics
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin only
 */
router.get("/stats", authenticate, requireRole("admin"), userController.getUserStats)

/**
 * @swagger
 * /users/facilitators:
 *   get:
 *     summary: Get all facilitators
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of all facilitators
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers and Admins only
 */
router.get("/facilitators", authenticate, requireRole("manager", "admin"), async (req, res) => {
  try {
    const { Facilitator, User } = require("../models")
    const facilitators = await Facilitator.findAll({
      include: [
        {
          model: User,
          as: "user",
          attributes: { exclude: ["password", "resetPasswordToken", "resetPasswordExpires"] },
        },
      ],
      order: [["createdAt", "DESC"]],
    })
    res.json({ facilitators })
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch facilitators" })
  }
})

/**
 * @swagger
 * /users/students:
 *   get:
 *     summary: Get all students
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of all students
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Managers, Facilitators and Admins only
 */
router.get("/students", authenticate, requireRole("manager", "facilitator", "admin"), async (req, res) => {
  try {
    const { Student, User, Cohort } = require("../models")
    const students = await Student.findAll({
      include: [
        {
          model: User,
          as: "user",
          attributes: { exclude: ["password", "resetPasswordToken", "resetPasswordExpires"] },
        },
        {
          model: Cohort,
          as: "cohort",
        },
      ],
      order: [["createdAt", "DESC"]],
    })
    res.json({ students })
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch students" })
  }
})

/**
 * @swagger
 * /users/{id}:
 *   get:
 *     summary: Get user by ID
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: User details
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden
 *       404:
 *         description: User not found
 */
router.get("/:id", authenticate, requireRole("admin", "manager"), validate("idParam"), userController.getUserById)

/**
 * @swagger
 * /users/{id}:
 *   put:
 *     summary: Update user
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               firstName:
 *                 type: string
 *               lastName:
 *                 type: string
 *               isActive:
 *                 type: boolean
 *     responses:
 *       200:
 *         description: User updated successfully
 *       400:
 *         description: Validation error
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin only
 *       404:
 *         description: User not found
 */
router.put("/:id", authenticate, requireRole("admin"), validate("idParam"), userController.updateUser)

/**
 * @swagger
 * /users/{id}/deactivate:
 *   patch:
 *     summary: Deactivate user
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: User deactivated successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin only
 *       404:
 *         description: User not found
 */
router.patch("/:id/deactivate", authenticate, requireRole("admin"), validate("idParam"), userController.deactivateUser)

/**
 * @swagger
 * /users/{id}:
 *   delete:
 *     summary: Delete user
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: User deleted successfully
 *       401:
 *         description: Unauthorized
 *       403:
 *         description: Forbidden - Admin only
 *       404:
 *         description: User not found
 */
router.delete("/:id", authenticate, requireRole("admin"), validate("idParam"), userController.deleteUser)

module.exports = router
```


/* ========== src\services\activityService.js ========== */
```javascript
const { 
  ActivityTracker, 
  CourseOffering, 
  Module, 
  Class,
  Cohort,
  Facilitator,
  User
} = require('../models');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class ActivityService {
  async createActivityLog(data, facilitatorId) {
    try {
      // Verify facilitator owns the course offering
      const courseOffering = await CourseOffering.findByPk(data.allocationId);
      
      if (!courseOffering) {
        throw new Error('Course offering not found');
      }
      
      if (courseOffering.facilitatorId !== facilitatorId) {
        throw new Error('You are not assigned to this course offering');
      }
      
      // Check for duplicate log
      const existing = await ActivityTracker.findOne({
        where: {
          allocationId: data.allocationId,
          weekNumber: data.weekNumber
        }
      });
      
      if (existing) {
        throw new Error(`Activity log already exists for week ${data.weekNumber}`);
      }
      
      // Create activity log
      const activityLog = await ActivityTracker.create(data);
      
      // Return with associations
      return this.getActivityLogById(activityLog.id);
    } catch (error) {
      logger.error('Create activity log error:', error);
      throw error;
    }
  }
  
  async getAllActivityLogs(filters = {}, page = 1, limit = 10) {
    try {
      const offset = (page - 1) * limit;
      const where = {};
      const courseOfferingWhere = {};
      
      // Apply filters
      if (filters.allocationId) where.allocationId = filters.allocationId;
      if (filters.weekNumber) where.weekNumber = filters.weekNumber;
      if (filters.facilitatorId) courseOfferingWhere.facilitatorId = filters.facilitatorId;
      
      // Status filter (based on completion)
      if (filters.status === 'complete') {
        where.submittedAt = { [Op.not]: null };
      } else if (filters.status === 'incomplete') {
        where.submittedAt = null;
      }
      
      const { count, rows } = await ActivityTracker.findAndCountAll({
        where,
        include: [
          {
            model: CourseOffering,
            as: 'courseOffering',
            where: courseOfferingWhere,
            include: [
              { model: Module, as: 'module' },
              { 
                model: Facilitator, 
                as: 'facilitator',
                include: [{ model: User, as: 'user' }]
              }
            ]
          }
        ],
        limit,
        offset,
        order: [['weekNumber', 'DESC'], ['createdAt', 'DESC']]
      });
      
      return {
        activityLogs: rows,
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(count / limit)
        }
      };
    } catch (error) {
      logger.error('Get activity logs error:', error);
      throw error;
    }
  }
  
  async getActivityLogById(id) {
    try {
      const activityLog = await ActivityTracker.findByPk(id, {
        include: [
          {
            model: CourseOffering,
            as: 'courseOffering',
            include: [
              { model: Module, as: 'module' },
              { model: Class, as: 'class' },
              { model: Cohort, as: 'cohort' },
              { 
                model: Facilitator, 
                as: 'facilitator',
                include: [{ model: User, as: 'user' }]
              }
            ]
          }
        ]
      });
      
      return activityLog;
    } catch (error) {
      logger.error('Get activity log by ID error:', error);
      throw error;
    }
  }
  
  async updateActivityLog(id, updates) {
    try {
      const activityLog = await ActivityTracker.findByPk(id);
      
      if (!activityLog) {
        return null;
      }
      
      // Don't allow changing allocation or week number
      delete updates.allocationId;
      delete updates.weekNumber;
      
      await activityLog.update(updates);
      
      return this.getActivityLogById(id);
    } catch (error) {
      logger.error('Update activity log error:', error);
      throw error;
    }
  }
  
  async deleteActivityLog(id) {
    try {
      const activityLog = await ActivityTracker.findByPk(id);
      
      if (!activityLog) {
        return false;
      }
      
      await activityLog.destroy();
      
      return true;
    } catch (error) {
      logger.error('Delete activity log error:', error);
      throw error;
    }
  }
  
  async getFacilitatorLogs(facilitatorId, filters = {}) {
    try {
      const where = {};
      
      if (filters.weekNumber) where.weekNumber = filters.weekNumber;
      if (filters.allocationId) where.allocationId = filters.allocationId;
      
      const logs = await ActivityTracker.findAll({
        where,
        include: [
          {
            model: CourseOffering,
            as: 'courseOffering',
            where: { facilitatorId },
            include: [
              { model: Module, as: 'module' },
              { model: Class, as: 'class' },
              { model: Cohort, as: 'cohort' }
            ]
          }
        ],
        order: [['weekNumber', 'DESC'], ['createdAt', 'DESC']]
      });
      
      return logs;
    } catch (error) {
      logger.error('Get facilitator logs error:', error);
      throw error;
    }
  }
  
  async checkFacilitatorOwnership(activityLogId, facilitatorId) {
    try {
      const activityLog = await ActivityTracker.findByPk(activityLogId, {
        include: [{
          model: CourseOffering,
          as: 'courseOffering',
          attributes: ['facilitatorId']
        }]
      });
      
      if (!activityLog) {
        return false;
      }
      
      return activityLog.courseOffering.facilitatorId === facilitatorId;
    } catch (error) {
      logger.error('Check facilitator ownership error:', error);
      throw error;
    }
  }
  
  async getWeeklySummary(weekNumber) {
    try {
      const logs = await ActivityTracker.findAll({
        where: { weekNumber },
        include: [
          {
            model: CourseOffering,
            as: 'courseOffering',
            include: [
              { model: Module, as: 'module' },
              { 
                model: Facilitator, 
                as: 'facilitator',
                include: [{ model: User, as: 'user' }]
              }
            ]
          }
        ]
      });
      
      const summary = {
        weekNumber,
        totalExpected: await CourseOffering.count({ where: { status: 'active' } }),
        totalSubmitted: logs.length,
        completeSubmissions: logs.filter(log => log.isComplete()).length,
        incompleteSubmissions: logs.filter(log => !log.isComplete()).length,
        submissions: logs.map(log => ({
          id: log.id,
          courseName: log.courseOffering.module.name,
          facilitatorName: log.courseOffering.facilitator.user.getFullName(),
          completionPercentage: log.getCompletionPercentage(),
          submittedAt: log.submittedAt,
          status: log.isComplete() ? 'Complete' : 'Incomplete'
        }))
      };
      
      return summary;
    } catch (error) {
      logger.error('Get weekly summary error:', error);
      throw error;
    }
  }
  
  async getMissingLogs(weekNumber) {
    try {
      // Get all active course offerings
      const activeCourses = await CourseOffering.findAll({
        where: { status: 'active' },
        include: [
          { model: Module, as: 'module' },
          { 
            model: Facilitator, 
            as: 'facilitator',
            include: [{ model: User, as: 'user' }]
          }
        ]
      });
      
      // Get submitted logs for the week
      const submittedLogs = await ActivityTracker.findAll({
        where: { weekNumber },
        attributes: ['allocationId']
      });
      
      const submittedAllocationIds = submittedLogs.map(log => log.allocationId);
      
      // Find courses without logs
      const missingLogs = activeCourses.filter(
        course => !submittedAllocationIds.includes(course.id)
      );
      
      return missingLogs.map(course => ({
        courseOfferingId: course.id,
        courseName: course.module.name,
        facilitatorName: course.facilitator.user.getFullName(),
        facilitatorEmail: course.facilitator.user.email
      }));
    } catch (error) {
      logger.error('Get missing logs error:', error);
      throw error;
    }
  }
}

module.exports = new ActivityService();
```


/* ========== src\services\authService.js ========== */
```javascript
const { User, Manager, Facilitator, Student } = require('../models');
const { sequelize } = require('../models');
const logger = require('../utils/logger');

class AuthService {
  async createUser(userData) {
    const transaction = await sequelize.transaction();
    
    try {
      // Create user
      const user = await User.create(userData, { transaction });
      
      // Create role-specific record
      switch (userData.role) {
        case 'manager':
          await Manager.create({
            userId: user.id,
            employeeId: userData.employeeId,
            department: userData.department
          }, { transaction });
          break;
          
        case 'facilitator':
          await Facilitator.create({
            userId: user.id,
            employeeId: userData.employeeId,
            department: userData.department,
            specialization: userData.specialization
          }, { transaction });
          break;
          
        case 'student':
          await Student.create({
            userId: user.id,
            studentId: userData.studentId,
            cohortId: userData.cohortId,
            enrollmentDate: new Date()
          }, { transaction });
          break;
      }
      
      await transaction.commit();
      
      // Reload user with associations
      const createdUser = await this.getUserProfile(user.id);
      return createdUser;
    } catch (error) {
      await transaction.rollback();
      logger.error('Create user error:', error);
      throw error;
    }
  }
  
  async authenticateUser(email, password) {
    try {
      const user = await User.findOne({
        where: { email, isActive: true }
      });
      
      if (!user) {
        return null;
      }
      
      const isPasswordValid = await user.validatePassword(password);
      if (!isPasswordValid) {
        return null;
      }
      
      // Update last login
      user.lastLogin = new Date();
      await user.save({ silent: true });
      
      return user;
    } catch (error) {
      logger.error('Authenticate user error:', error);
      throw error;
    }
  }
  
  async getUserById(id) {
    try {
      const user = await User.findByPk(id);
      return user;
    } catch (error) {
      logger.error('Get user by ID error:', error);
      throw error;
    }
  }
  
  async getUserProfile(userId) {
    try {
      const user = await User.findByPk(userId, {
        include: [
          { model: Manager, as: 'manager' },
          { model: Facilitator, as: 'facilitator' },
          { 
            model: Student, 
            as: 'student',
            include: ['cohort']
          }
        ]
      });
      
      return user;
    } catch (error) {
      logger.error('Get user profile error:', error);
      throw error;
    }
  }
  
  async updateUserProfile(userId, updates) {
    try {
      const user = await User.findByPk(userId);
      
      if (!user) {
        throw new Error('User not found');
      }
      
      // Only allow updating certain fields
      const allowedFields = ['firstName', 'lastName'];
      const filteredUpdates = {};
      
      allowedFields.forEach(field => {
        if (updates[field] !== undefined) {
          filteredUpdates[field] = updates[field];
        }
      });
      
      await user.update(filteredUpdates);
      
      return this.getUserProfile(userId);
    } catch (error) {
      logger.error('Update user profile error:', error);
      throw error;
    }
  }
  
  async changePassword(userId, currentPassword, newPassword) {
    try {
      const user = await User.findByPk(userId);
      
      if (!user) {
        throw new Error('User not found');
      }
      
      const isPasswordValid = await user.validatePassword(currentPassword);
      if (!isPasswordValid) {
        return false;
      }
      
      user.password = newPassword;
      await user.save();
      
      return true;
    } catch (error) {
      logger.error('Change password error:', error);
      throw error;
    }
  }
  
  async resetPassword(email) {
    try {
      const user = await User.findOne({ where: { email } });
      
      if (!user) {
        // Don't reveal if user exists
        return true;
      }
      
      // Generate reset token
      const resetToken = require('crypto').randomBytes(32).toString('hex');
      const resetExpires = new Date();
      resetExpires.setHours(resetExpires.getHours() + 1); // 1 hour expiry
      
      user.resetPasswordToken = resetToken;
      user.resetPasswordExpires = resetExpires;
      await user.save();
      
      // TODO: Send reset email
      logger.info(`Password reset token generated for ${email}`);
      
      return true;
    } catch (error) {
      logger.error('Reset password error:', error);
      throw error;
    }
  }
}

module.exports = new AuthService();
```


/* ========== src\services\courseService.js ========== */
```javascript
const { 
  CourseOffering, 
  Module, 
  Class, 
  Cohort, 
  Facilitator, 
  Mode,
  User,
  ActivityTracker 
} = require('../models');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class CourseService {
  async createCourseOffering(data) {
    try {
      // Check for duplicate course offering
      const existing = await CourseOffering.findOne({
        where: {
          moduleId: data.moduleId,
          classId: data.classId,
          cohortId: data.cohortId,
          trimester: data.trimester,
          intakePeriod: data.intakePeriod
        }
      });
      
      if (existing) {
        throw new Error('Course offering already exists for this combination');
      }
      
      // Create course offering
      const courseOffering = await CourseOffering.create(data);
      
      // Update facilitator course load if assigned
      if (data.facilitatorId) {
        await this.updateFacilitatorLoad(data.facilitatorId, 1);
      }
      
      // Return with associations
      return this.getCourseOfferingById(courseOffering.id);
    } catch (error) {
      logger.error('Create course offering error:', error);
      throw error;
    }
  }
  
  async getAllCourseOfferings(filters = {}, page = 1, limit = 10) {
    try {
      const offset = (page - 1) * limit;
      const where = {};
      
      // Apply filters
      if (filters.trimester) where.trimester = filters.trimester;
      if (filters.cohortId) where.cohortId = filters.cohortId;
      if (filters.facilitatorId) where.facilitatorId = filters.facilitatorId;
      if (filters.intakePeriod) where.intakePeriod = filters.intakePeriod;
      if (filters.modeId) where.modeId = filters.modeId;
      if (filters.status) where.status = filters.status;
      
      const { count, rows } = await CourseOffering.findAndCountAll({
        where,
        include: [
          { model: Module, as: 'module' },
          { model: Class, as: 'class' },
          { model: Cohort, as: 'cohort' },
          { 
            model: Facilitator, 
            as: 'facilitator',
            include: [{ model: User, as: 'user' }]
          },
          { model: Mode, as: 'mode' }
        ],
        limit,
        offset,
        order: [['createdAt', 'DESC']]
      });
      
      return {
        courseOfferings: rows,
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(count / limit)
        }
      };
    } catch (error) {
      logger.error('Get course offerings error:', error);
      throw error;
    }
  }
  
  async getCourseOfferingById(id) {
    try {
      const courseOffering = await CourseOffering.findByPk(id, {
        include: [
          { model: Module, as: 'module' },
          { model: Class, as: 'class' },
          { model: Cohort, as: 'cohort' },
          { 
            model: Facilitator, 
            as: 'facilitator',
            include: [{ model: User, as: 'user' }]
          },
          { model: Mode, as: 'mode' },
          { 
            model: ActivityTracker, 
            as: 'activityLogs',
            order: [['weekNumber', 'ASC']]
          }
        ]
      });
      
      return courseOffering;
    } catch (error) {
      logger.error('Get course offering by ID error:', error);
      throw error;
    }
  }
  
  async updateCourseOffering(id, updates) {
    try {
      const courseOffering = await CourseOffering.findByPk(id);
      
      if (!courseOffering) {
        return null;
      }
      
      // Handle facilitator change
      if (updates.facilitatorId && updates.facilitatorId !== courseOffering.facilitatorId) {
        // Decrease old facilitator's load
        if (courseOffering.facilitatorId) {
          await this.updateFacilitatorLoad(courseOffering.facilitatorId, -1);
        }
        // Increase new facilitator's load
        await this.updateFacilitatorLoad(updates.facilitatorId, 1);
      }
      
      // Update course offering
      await courseOffering.update(updates);
      
      return this.getCourseOfferingById(id);
    } catch (error) {
      logger.error('Update course offering error:', error);
      throw error;
    }
  }
  
  async deleteCourseOffering(id) {
    try {
      const courseOffering = await CourseOffering.findByPk(id);
      
      if (!courseOffering) {
        return false;
      }
      
      // Update facilitator load
      if (courseOffering.facilitatorId) {
        await this.updateFacilitatorLoad(courseOffering.facilitatorId, -1);
      }
      
      // Soft delete
      await courseOffering.destroy();
      
      return true;
    } catch (error) {
      logger.error('Delete course offering error:', error);
      throw error;
    }
  }
  
// Update the assignFacilitator method:
async assignFacilitator(courseOfferingId, facilitatorId) {
  const transaction = await sequelize.transaction();
  
  try {
    const courseOffering = await CourseOffering.findByPk(courseOfferingId, { transaction });
    
    if (!courseOffering) {
      throw new Error('Course offering not found');
    }
    
    const facilitator = await Facilitator.findByPk(facilitatorId, { transaction });
    
    if (!facilitator) {
      throw new Error('Facilitator not found');
    }
    
    if (!facilitator.isAvailable) {
      throw new Error('Facilitator is not available');
    }
    
    if (!facilitator.canTakeMoreCourses()) {
      throw new Error(`Facilitator has reached maximum course load (${facilitator.maxCourseLoad})`);
    }
    
    // Update facilitator assignment
    const oldFacilitatorId = courseOffering.facilitatorId;
    courseOffering.facilitatorId = facilitatorId;
    await courseOffering.save({ transaction });
    
    // Update course loads
    if (oldFacilitatorId && oldFacilitatorId !== facilitatorId) {
      await this.updateFacilitatorLoad(oldFacilitatorId, -1, transaction);
    }
    await this.updateFacilitatorLoad(facilitatorId, 1, transaction);
    
    await transaction.commit();
    
    return this.getCourseOfferingById(courseOfferingId);
  } catch (error) {
    await transaction.rollback();
    logger.error('Assign facilitator error:', error);
    throw error;
  }
}
  
  async getFacilitatorCourses(facilitatorId) {
    try {
      const courses = await CourseOffering.findAll({
        where: { 
          facilitatorId,
          status: { [Op.in]: ['planned', 'active'] }
        },
        include: [
          { model: Module, as: 'module' },
          { model: Class, as: 'class' },
          { model: Cohort, as: 'cohort' },
          { model: Mode, as: 'mode' },
          { 
            model: ActivityTracker, 
            as: 'activityLogs',
            required: false
          }
        ],
        order: [['startDate', 'ASC']]
      });
      
      return courses;
    } catch (error) {
      logger.error('Get facilitator courses error:', error);
      throw error;
    }
  }
  
  async updateFacilitatorLoad(facilitatorId, change) {
    try {
      const facilitator = await Facilitator.findByPk(facilitatorId);
      if (facilitator) {
        facilitator.currentCourseLoad += change;
        await facilitator.save();
      }
    } catch (error) {
      logger.error('Update facilitator load error:', error);
      throw error;
    }
  }
  
  async createModule(moduleData) {
    try {
      const module = await Module.create(moduleData);
      return module;
    } catch (error) {
      logger.error('Create module error:', error);
      throw error;
    }
  }
  
  async getAllModules() {
    try {
      const modules = await Module.findAll({
        where: { isActive: true },
        order: [['code', 'ASC']]
      });
      return modules;
    } catch (error) {
      logger.error('Get modules error:', error);
      throw error;
    }
  }
  
  async createClass(classData) {
    try {
      const classEntity = await Class.create(classData);
      return classEntity;
    } catch (error) {
      logger.error('Create class error:', error);
      throw error;
    }
  }
  
  async createCohort(cohortData) {
    try {
      const cohort = await Cohort.create(cohortData);
      return cohort;
    } catch (error) {
      logger.error('Create cohort error:', error);
      throw error;
    }
  }
  
  async getAvailableFacilitators() {
    try {
      const facilitators = await Facilitator.findAll({
        where: { isAvailable: true },
        include: [{ model: User, as: 'user' }],
        order: [['currentCourseLoad', 'ASC']]
      });
      
      return facilitators.filter(f => f.canTakeMoreCourses());
    } catch (error) {
      logger.error('Get available facilitators error:', error);
      throw error;
    }
  }
}

module.exports = new CourseService();
```


/* ========== src\services\notificationService.js ========== */
```javascript
const { notificationQueue, reminderQueue } = require('../config/redis');
const { User, Facilitator, Manager, ActivityTracker, CourseOffering } = require('../models');
const logger = require('../utils/logger');
const { Op } = require('sequelize');

class NotificationService {
  // Queue a notification
  async queueNotification(type, data) {
    try {
      const job = await notificationQueue.add(type, data);
      logger.info(`Notification queued: ${type}, Job ID: ${job.id}`);
      return job;
    } catch (error) {
      logger.error('Failed to queue notification:', error);
      throw error;
    }
  }

  // Queue a reminder
  async queueReminder(data, delay = 0) {
    try {
      const job = await reminderQueue.add('activity-reminder', data, { delay });
      logger.info(`Reminder queued for delay: ${delay}ms, Job ID: ${job.id}`);
      return job;
    } catch (error) {
      logger.error('Failed to queue reminder:', error);
      throw error;
    }
  }

  // Send reminder to facilitator
  async sendFacilitatorReminder(facilitatorId, courseOfferingId, weekNumber) {
    try {
      const facilitator = await Facilitator.findByPk(facilitatorId, {
        include: [{ model: User, as: 'user' }]
      });

      if (!facilitator) {
        throw new Error('Facilitator not found');
      }

      const courseOffering = await CourseOffering.findByPk(courseOfferingId, {
        include: ['module', 'class', 'cohort']
      });

      const notificationData = {
        to: facilitator.user.email,
        subject: `Activity Log Reminder - Week ${weekNumber}`,
        template: 'activity-reminder',
        data: {
          facilitatorName: facilitator.user.getFullName(),
          courseName: courseOffering.module.name,
          className: courseOffering.class.name,
          cohortName: courseOffering.cohort.name,
          weekNumber,
          dueDate: this.calculateDueDate()
        }
      };

      await this.queueNotification('email', notificationData);
      
      // Update activity tracker reminder count
      const activityLog = await ActivityTracker.findOne({
        where: {
          allocationId: courseOfferingId,
          weekNumber
        }
      });

      if (activityLog) {
        await activityLog.incrementReminderCount();
      }

      return true;
    } catch (error) {
      logger.error('Failed to send facilitator reminder:', error);
      throw error;
    }
  }

  // Send alert to managers
  async sendManagerAlert(type, data) {
    try {
      const managers = await Manager.findAll({
        include: [{ model: User, as: 'user', where: { isActive: true } }]
      });

      const notifications = managers.map(manager => ({
        to: manager.user.email,
        subject: this.getAlertSubject(type),
        template: 'manager-alert',
        data: {
          managerName: manager.user.getFullName(),
          alertType: type,
          ...data
        }
      }));

      // Queue all notifications
      await Promise.all(
        notifications.map(notification => 
          this.queueNotification('email', notification)
        )
      );

      return true;
    } catch (error) {
      logger.error('Failed to send manager alert:', error);
      throw error;
    }
  }

  // Check for missing activity logs and send reminders
  async checkAndSendReminders() {
    try {
      const currentWeek = this.getCurrentWeek();
      const deadlineHours = parseInt(process.env.NOTIFICATION_DEADLINE_HOURS) || 48;
      const deadline = new Date();
      deadline.setHours(deadline.getHours() - deadlineHours);

      // Find all active course offerings
      const activeOfferings = await CourseOffering.findAll({
        where: { status: 'active' },
        include: ['facilitator']
      });

      for (const offering of activeOfferings) {
        // Check if activity log exists for current week
        const activityLog = await ActivityTracker.findOne({
          where: {
            allocationId: offering.id,
            weekNumber: currentWeek
          }
        });

        // If no log or incomplete log past deadline
        if (!activityLog || (!activityLog.submittedAt && activityLog.createdAt < deadline)) {
          // Send reminder if not sent recently (within 24 hours)
          const lastReminderTime = activityLog?.lastReminderSent || new Date(0);
          const hoursSinceLastReminder = (Date.now() - lastReminderTime) / (1000 * 60 * 60);
          
          if (hoursSinceLastReminder > 24) {
            await this.sendFacilitatorReminder(
              offering.facilitatorId,
              offering.id,
              currentWeek
            );
          }
        }

        // Alert managers about critical missing logs
        if (!activityLog && new Date() > deadline) {
          await this.sendManagerAlert('missing-activity-log', {
            facilitatorName: offering.facilitator.user.getFullName(),
            courseName: offering.module.name,
            weekNumber: currentWeek
          });
        }
      }

      return true;
    } catch (error) {
      logger.error('Failed to check and send reminders:', error);
      throw error;
    }
  }

  // Calculate due date for activity logs
  calculateDueDate() {
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 2); // 48 hours from now
    return dueDate;
  }

  // Get current week number (simplified - in production, calculate based on course start date)
  getCurrentWeek() {
    // This is a simplified version. In production, calculate based on course start date
    const startOfYear = new Date(new Date().getFullYear(), 0, 1);
    const weekNumber = Math.ceil(((new Date() - startOfYear) / 86400000 + 1) / 7);
    return weekNumber % 16 || 16; // Assuming 16-week courses
  }

  // Get alert subject based on type
  getAlertSubject(type) {
    const subjects = {
      'missing-activity-log': 'Missing Activity Log Alert',
      'activity-submitted': 'Activity Log Submitted',
      'deadline-missed': 'Activity Log Deadline Missed',
      'course-update': 'Course Allocation Update'
    };
    return subjects[type] || 'System Alert';
  }

  // Process submission notification
  async notifyActivitySubmission(activityTrackerId) {
    try {
      const activityLog = await ActivityTracker.findByPk(activityTrackerId, {
        include: [{
          model: CourseOffering,
          as: 'courseOffering',
          include: ['module', 'facilitator']
        }]
      });

      if (!activityLog) {
        throw new Error('Activity log not found');
      }

      // Notify managers about submission
      await this.sendManagerAlert('activity-submitted', {
        facilitatorName: activityLog.courseOffering.facilitator.user.getFullName(),
        courseName: activityLog.courseOffering.module.name,
        weekNumber: activityLog.weekNumber,
        completionPercentage: activityLog.getCompletionPercentage(),
        submittedAt: activityLog.submittedAt
      });

      return true;
    } catch (error) {
      logger.error('Failed to notify activity submission:', error);
      throw error;
    }
  }
}

module.exports = new NotificationService();
```


/* ========== src\utils\constants.js ========== */
```javascript
module.exports = {
  // User roles
  ROLES: {
    ADMIN: 'admin',
    MANAGER: 'manager',
    FACILITATOR: 'facilitator',
    STUDENT: 'student'
  },

  // Course status
  COURSE_STATUS: {
    PLANNED: 'planned',
    ACTIVE: 'active',
    COMPLETED: 'completed',
    CANCELLED: 'cancelled'
  },

  // Activity status
  ACTIVITY_STATUS: {
    DONE: 'Done',
    PENDING: 'Pending',
    NOT_STARTED: 'Not Started'
  },

  // Intake periods
  INTAKE_PERIODS: {
    HT1: 'HT1',
    HT2: 'HT2',
    FT: 'FT'
  },

  // Mode types
  MODE_TYPES: {
    ONLINE: 'Online',
    IN_PERSON: 'In-person',
    HYBRID: 'Hybrid'
  },

  // Student status
  STUDENT_STATUS: {
    ACTIVE: 'active',
    INACTIVE: 'inactive',
    GRADUATED: 'graduated',
    WITHDRAWN: 'withdrawn'
  },

  // Management levels
  MANAGEMENT_LEVELS: {
    SENIOR: 'senior',
    MIDDLE: 'middle',
    JUNIOR: 'junior'
  },

  // Module levels
  MODULE_LEVELS: ['100', '200', '300', '400', '500', '600'],

  // Validation limits
  LIMITS: {
    MAX_WEEKS: 16,
    MAX_TRIMESTER: 3,
    MIN_TRIMESTER: 1,
    MAX_STUDENTS: 500,
    MIN_STUDENTS: 1,
    MAX_COURSE_LOAD: 10,
    MIN_PASSWORD_LENGTH: 8,
    MAX_NAME_LENGTH: 100,
    MIN_NAME_LENGTH: 2,
    MAX_EMAIL_LENGTH: 255,
    PAGINATION_DEFAULT_LIMIT: 10,
    PAGINATION_MAX_LIMIT: 100
  },

  // Notification types
  NOTIFICATION_TYPES: {
    ACTIVITY_REMINDER: 'activity-reminder',
    ACTIVITY_SUBMITTED: 'activity-submitted',
    DEADLINE_MISSED: 'deadline-missed',
    COURSE_UPDATE: 'course-update',
    EMAIL: 'email'
  },

  // HTTP status codes
  HTTP_STATUS: {
    OK: 200,
    CREATED: 201,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    CONFLICT: 409,
    INTERNAL_SERVER_ERROR: 500
  },

  // Error messages
  ERROR_MESSAGES: {
    UNAUTHORIZED: 'Authentication required',
    FORBIDDEN: 'Access denied',
    NOT_FOUND: 'Resource not found',
    VALIDATION_FAILED: 'Validation failed',
    DUPLICATE_ENTRY: 'Resource already exists',
    INTERNAL_ERROR: 'An unexpected error occurred'
  },

  // Success messages
  SUCCESS_MESSAGES: {
    CREATED: 'Resource created successfully',
    UPDATED: 'Resource updated successfully',
    DELETED: 'Resource deleted successfully',
    LOGIN_SUCCESS: 'Login successful',
    LOGOUT_SUCCESS: 'Logout successful'
  }
};
```


/* ========== src\utils\helpers.js ========== */
```javascript
const crypto = require('crypto');

/**
 * Generate a random string
 * @param {number} length - Length of the string
 * @returns {string} Random string
 */
const generateRandomString = (length = 32) => {
  return crypto.randomBytes(Math.ceil(length / 2))
    .toString('hex')
    .slice(0, length);
};

/**
 * Calculate pagination offset
 * @param {number} page - Current page
 * @param {number} limit - Items per page
 * @returns {number} Offset value
 */
const calculateOffset = (page, limit) => {
  return (page - 1) * limit;
};

/**
 * Format pagination response
 * @param {number} total - Total items
 * @param {number} page - Current page
 * @param {number} limit - Items per page
 * @returns {object} Pagination metadata
 */
const formatPaginationResponse = (total, page, limit) => {
  return {
    total,
    page: parseInt(page),
    limit: parseInt(limit),
    pages: Math.ceil(total / limit),
    hasNext: page < Math.ceil(total / limit),
    hasPrev: page > 1
  };
};

/**
 * Generate employee ID
 * @param {string} prefix - ID prefix
 * @returns {string} Employee ID
 */
const generateEmployeeId = (prefix = 'EMP') => {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substr(2, 5);
  return `${prefix}${timestamp}${random}`.toUpperCase();
};

/**
 * Generate student ID
 * @param {number} year - Enrollment year
 * @returns {string} Student ID
 */
const generateStudentId = (year = new Date().getFullYear()) => {
  const random = Math.floor(Math.random() * 90000) + 10000;
  return `${year}${random}`;
};

/**
 * Calculate week number from dates
 * @param {Date} startDate - Course start date
 * @param {Date} currentDate - Current date
 * @returns {number} Week number
 */
const calculateWeekNumber = (startDate, currentDate = new Date()) => {
  const start = new Date(startDate);
  const current = new Date(currentDate);
  
  // Calculate the difference in milliseconds
  const diffTime = current - start;
  
  // If current date is before start date, return 0
  if (diffTime < 0) {
    return 0;
  }
  
  // Convert to days and then to weeks
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  const weekNumber = Math.floor(diffDays / 7) + 1;
  
  return weekNumber;
};

/**
 * Validate date range
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {boolean} Is valid range
 */
const isValidDateRange = (startDate, endDate) => {
  const start = new Date(startDate);
  const end = new Date(endDate);
  return start < end;
};

/**
 * Format date for display
 * @param {Date} date - Date to format
 * @returns {string} Formatted date
 */
const formatDate = (date) => {
  return new Date(date).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

/**
 * Sleep function for delays
 * @param {number} ms - Milliseconds to sleep
 * @returns {Promise} Promise that resolves after delay
 */
const sleep = (ms) => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * Sanitize input string
 * @param {string} input - Input string
 * @returns {string} Sanitized string
 */
const sanitizeInput = (input) => {
  if (typeof input !== 'string') return input;
  return input.trim().replace(/[<>]/g, '');
};

/**
 * Check if user has role
 * @param {object} user - User object
 * @param {string[]} allowedRoles - Allowed roles
 * @returns {boolean} Has role
 */
const hasRole = (user, allowedRoles) => {
  return allowedRoles.includes(user.role);
};

/**
 * Parse boolean from string
 * @param {string} value - String value
 * @returns {boolean} Boolean value
 */
const parseBoolean = (value) => {
  if (typeof value === 'boolean') return value;
  return value === 'true' || value === '1' || value === 'yes';
};

module.exports = {
  generateRandomString,
  calculateOffset,
  formatPaginationResponse,
  generateEmployeeId,
  generateStudentId,
  calculateWeekNumber,
  isValidDateRange,
  formatDate,
  sleep,
  sanitizeInput,
  hasRole,
  parseBoolean
};
```


/* ========== src\utils\logger.js ========== */
```javascript
const winston = require('winston');
const path = require('path');
const fs = require('fs');

// Create logs directory if it doesn't exist
const logDir = 'logs';
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir);
}

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4
};

// Define log colors
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white'
};

winston.addColors(colors);

// Define log format
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Define log transports
const transports = [
  // Console transport
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize({ all: true }),
      winston.format.printf(
        info => `${info.timestamp} ${info.level}: ${info.message}`
      )
    )
  })
];

// Add file transport in production
if (process.env.NODE_ENV === 'production') {
  transports.push(
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  );
}

// Create logger instance
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'debug',
  levels,
  format,
  transports,
  exitOnError: false
});

module.exports = logger;
```


/* ========== src\utils\seedDatabase.js ========== */
```javascript
require('dotenv').config();
const { 
  sequelize, 
  User, 
  Manager, 
  Facilitator, 
  Student, 
  Module, 
  Class, 
  Cohort, 
  Mode,
  CourseOffering,
  ActivityTracker 
} = require('../models');
const logger = require('./logger');

const seedDatabase = async () => {
  try {
    // Sync database
    await sequelize.sync({ force: true });
    logger.info('Database synced successfully');

    // Create Modes
    const modes = await Mode.bulkCreate([
      { name: 'Online', description: 'Online delivery', requiresPhysicalPresence: false },
      { name: 'In-person', description: 'Traditional classroom delivery', requiresPhysicalPresence: true },
      { name: 'Hybrid', description: 'Mix of online and in-person', requiresPhysicalPresence: true }
    ]);
    logger.info('Modes created');

    // Create Classes
    const classes = await Class.bulkCreate([
      { name: '2024S', year: 2024, section: 'S', description: 'Spring 2024' },
      { name: '2024F', year: 2024, section: 'F', description: 'Fall 2024' },
      { name: '2025S', year: 2025, section: 'S', description: 'Spring 2025' },
      { name: '2025F', year: 2025, section: 'F', description: 'Fall 2025' }
    ]);
    logger.info('Classes created');

    // Create Cohorts
    const cohorts = await Cohort.bulkCreate([
      {
        name: 'Software Engineering 2024',
        code: 'SE2024',
        startDate: '2024-01-01',
        endDate: '2027-12-31',
        program: 'Software Engineering'
      },
      {
        name: 'Computer Science 2024',
        code: 'CS2024',
        startDate: '2024-01-01',
        endDate: '2027-12-31',
        program: 'Computer Science'
      },
      {
        name: 'Data Science 2025',
        code: 'DS2025',
        startDate: '2025-01-01',
        endDate: '2028-12-31',
        program: 'Data Science'
      }
    ]);
    logger.info('Cohorts created');

    // Create Modules
    const modules = await Module.bulkCreate([
      {
        code: 'CS101',
        name: 'Introduction to Computer Science',
        description: 'Fundamental concepts of computer science',
        credits: 3,
        level: '100'
      },
      {
        code: 'CS201',
        name: 'Data Structures and Algorithms',
        description: 'Study of data organization and algorithmic thinking',
        credits: 4,
        level: '200'
      },
      {
        code: 'SE101',
        name: 'Software Engineering Principles',
        description: 'Introduction to software development methodologies',
        credits: 3,
        level: '100'
      },
      {
        code: 'DB201',
        name: 'Database Management Systems',
        description: 'Design and implementation of database systems',
        credits: 3,
        level: '200'
      },
      {
        code: 'WEB301',
        name: 'Web Development',
        description: 'Modern web application development',
        credits: 4,
        level: '300'
      }
    ]);
    logger.info('Modules created');

    // Create Admin User
    const adminUser = await User.create({
      email: 'admin@university.edu',
      password: 'Admin123!',
      firstName: 'System',
      lastName: 'Administrator',
      role: 'admin'
    });
    logger.info('Admin user created');

    // Create Managers
    const manager1User = await User.create({
      email: 'sarah.johnson@university.edu',
      password: 'Manager123!',
      firstName: 'Sarah',
      lastName: 'Johnson',
      role: 'manager'
    });
    const manager1 = await Manager.create({
      userId: manager1User.id,
      employeeId: 'EMP001',
      department: 'Computer Science',
      managementLevel: 'senior'
    });

    const manager2User = await User.create({
      email: 'michael.chen@university.edu',
      password: 'Manager123!',
      firstName: 'Michael',
      lastName: 'Chen',
      role: 'manager'
    });
    const manager2 = await Manager.create({
      userId: manager2User.id,
      employeeId: 'EMP002',
      department: 'Software Engineering',
      managementLevel: 'middle'
    });
    logger.info('Managers created');

    // Create Facilitators
    const facilitator1User = await User.create({
      email: 'john.doe@university.edu',
      password: 'Facilitator123!',
      firstName: 'John',
      lastName: 'Doe',
      role: 'facilitator'
    });
    const facilitator1 = await Facilitator.create({
      userId: facilitator1User.id,
      employeeId: 'EMP101',
      department: 'Computer Science',
      specialization: 'Algorithms and Data Structures',
      experienceYears: 5,
      maxCourseLoad: 4
    });

    const facilitator2User = await User.create({
      email: 'jane.smith@university.edu',
      password: 'Facilitator123!',
      firstName: 'Jane',
      lastName: 'Smith',
      role: 'facilitator'
    });
    const facilitator2 = await Facilitator.create({
      userId: facilitator2User.id,
      employeeId: 'EMP102',
      department: 'Software Engineering',
      specialization: 'Web Development',
      experienceYears: 7,
      maxCourseLoad: 3
    });

    const facilitator3User = await User.create({
      email: 'robert.wilson@university.edu',
      password: 'Facilitator123!',
      firstName: 'Robert',
      lastName: 'Wilson',
      role: 'facilitator'
    });
    const facilitator3 = await Facilitator.create({
      userId: facilitator3User.id,
      employeeId: 'EMP103',
      department: 'Computer Science',
      specialization: 'Database Systems',
      experienceYears: 10,
      maxCourseLoad: 3
    });
    logger.info('Facilitators created');

    // Create Students
    const students = [];
    for (let i = 1; i <= 10; i++) {
      const studentUser = await User.create({
        email: `student${i}@university.edu`,
        password: 'Student123!',
        firstName: `Student${i}`,
        lastName: `Test${i}`,
        role: 'student'
      });
      
      const student = await Student.create({
        userId: studentUser.id,
        studentId: `2024000${i.toString().padStart(3, '0')}`,
        cohortId: cohorts[i % 3].id,
        enrollmentDate: new Date(),
        expectedGraduation: new Date('2027-12-31'),
        status: 'active'
      });
      students.push(student);
    }
    logger.info('Students created');

    // Create Course Offerings
    const courseOfferings = await CourseOffering.bulkCreate([
      {
        moduleId: modules[0].id, // CS101
        classId: classes[2].id, // 2025S
        cohortId: cohorts[0].id, // SE2024
        facilitatorId: facilitator1.id,
        modeId: modes[0].id, // Online
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-01-15',
        endDate: '2025-04-30',
        maxStudents: 30,
        status: 'active'
      },
      {
        moduleId: modules[1].id, // CS201
        classId: classes[2].id, // 2025S
        cohortId: cohorts[1].id, // CS2024
        facilitatorId: facilitator1.id,
        modeId: modes[1].id, // In-person
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-01-15',
        endDate: '2025-04-30',
        maxStudents: 25,
        status: 'active'
      },
      {
        moduleId: modules[2].id, // SE101
        classId: classes[2].id, // 2025S
        cohortId: cohorts[0].id, // SE2024
        facilitatorId: facilitator2.id,
        modeId: modes[2].id, // Hybrid
        trimester: 1,
        intakePeriod: 'FT',
        startDate: '2025-01-15',
        endDate: '2025-04-30',
        maxStudents: 35,
        status: 'active'
      },
      {
        moduleId: modules[3].id, // DB201
        classId: classes[2].id, // 2025S
        cohortId: cohorts[1].id, // CS2024
        facilitatorId: facilitator3.id,
        modeId: modes[0].id, // Online
        trimester: 2,
        intakePeriod: 'HT2',
        startDate: '2025-05-01',
        endDate: '2025-08-15',
        maxStudents: 20,
        status: 'planned'
      }
    ]);
    logger.info('Course offerings created');

    // Update facilitator course loads
    await facilitator1.update({ currentCourseLoad: 2 });
    await facilitator2.update({ currentCourseLoad: 1 });
    await facilitator3.update({ currentCourseLoad: 1 });

    // Create sample Activity Logs
    const activityLogs = await ActivityTracker.bulkCreate([
      {
        allocationId: courseOfferings[0].id,
        weekNumber: 1,
        attendance: [true, true, false, true, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Done',
        summativeGrading: 'Pending',
        courseModeration: 'Done',
        intranetSync: 'Done',
        gradeBookStatus: 'Pending',
        submittedAt: new Date(),
        notes: 'Week 1 completed'
      },
      {
        allocationId: courseOfferings[1].id,
        weekNumber: 1,
        attendance: [true, true, true, true, false, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Pending',
        summativeGrading: 'Not Started',
        courseModeration: 'Pending',
        intranetSync: 'Done',
        gradeBookStatus: 'Not Started'
      },
      {
        allocationId: courseOfferings[2].id,
        weekNumber: 1,
        attendance: [true, true, true, true, true, true, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Done',
        summativeGrading: 'Done',
        courseModeration: 'Done',
        intranetSync: 'Done',
        gradeBookStatus: 'Done',
        submittedAt: new Date(),
        notes: 'All tasks completed for week 1'
      }
    ]);
    logger.info('Activity logs created');

    logger.info('Database seeding completed successfully!');
    logger.info('\nLogin Credentials:');
    logger.info('Admin: admin@university.edu / Admin123!');
    logger.info('Manager: sarah.johnson@university.edu / Manager123!');
    logger.info('Facilitator: john.doe@university.edu / Facilitator123!');
    logger.info('Student: student1@university.edu / Student123!');

  } catch (error) {
    logger.error('Error seeding database:', error);
    throw error;
  } finally {
    await sequelize.close();
  }
};

// Run seeder if called directly
if (require.main === module) {
  seedDatabase()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}

module.exports = seedDatabase;
```


/* ========== src\utils\validators.js ========== */
```javascript
/**
 * Custom validators for the application
 */

/**
 * Validate email format
 * @param {string} email - Email address
 * @returns {boolean} Is valid email
 */
const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

/**
 * Validate password strength
 * @param {string} password - Password
 * @returns {object} Validation result
 */
const validatePassword = (password) => {
  const result = {
    isValid: true,
    errors: []
  };

  if (password.length < 8) {
    result.errors.push('Password must be at least 8 characters long');
  }

  if (!/[a-z]/.test(password)) {
    result.errors.push('Password must contain at least one lowercase letter');
  }

  if (!/[A-Z]/.test(password)) {
    result.errors.push('Password must contain at least one uppercase letter');
  }

  if (!/\d/.test(password)) {
    result.errors.push('Password must contain at least one number');
  }

  result.isValid = result.errors.length === 0;
  return result;
};

/**
 * Validate phone number
 * @param {string} phone - Phone number
 * @returns {boolean} Is valid phone
 */
const isValidPhone = (phone) => {
  const phoneRegex = /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{4,6}$/;
  return phoneRegex.test(phone);
};

/**
 * Validate date format
 * @param {string} date - Date string
 * @returns {boolean} Is valid date
 */
const isValidDate = (date) => {
  const parsed = Date.parse(date);
  return !isNaN(parsed);
};

/**
 * Validate trimester value
 * @param {number} trimester - Trimester value
 * @returns {boolean} Is valid trimester
 */
const isValidTrimester = (trimester) => {
  return Number.isInteger(trimester) && trimester >= 1 && trimester <= 3;
};

/**
 * Validate week number
 * @param {number} week - Week number
 * @returns {boolean} Is valid week
 */
const isValidWeekNumber = (week) => {
  return Number.isInteger(week) && week >= 1 && week <= 16;
};

/**
 * Validate attendance array
 * @param {array} attendance - Attendance array
 * @returns {boolean} Is valid attendance array
 */
const isValidAttendanceArray = (attendance) => {
  if (!Array.isArray(attendance)) return false;
  return attendance.every(item => typeof item === 'boolean');
};

/**
 * Validate intake period
 * @param {string} intake - Intake period
 * @returns {boolean} Is valid intake
 */
const isValidIntakePeriod = (intake) => {
  return ['HT1', 'HT2', 'FT'].includes(intake);
};

/**
 * Validate student ID format
 * @param {string} studentId - Student ID
 * @returns {boolean} Is valid student ID
 */
const isValidStudentId = (studentId) => {
  const studentIdRegex = /^\d{9}$/;
  return studentIdRegex.test(studentId);
};

/**
 * Validate employee ID format
 * @param {string} employeeId - Employee ID
 * @returns {boolean} Is valid employee ID
 */
const isValidEmployeeId = (employeeId) => {
  const employeeIdRegex = /^EMP[A-Z0-9]{8,}$/;
  return employeeIdRegex.test(employeeId);
};

/**
 * Validate module code format
 * @param {string} code - Module code
 * @returns {boolean} Is valid module code
 */
const isValidModuleCode = (code) => {
  const moduleCodeRegex = /^[A-Z]{2,4}\d{3}$/;
  return moduleCodeRegex.test(code);
};

/**
 * Validate GPA value
 * @param {number} gpa - GPA value
 * @returns {boolean} Is valid GPA
 */
const isValidGPA = (gpa) => {
  return typeof gpa === 'number' && gpa >= 0 && gpa <= 4.0;
};

module.exports = {
  isValidEmail,
  validatePassword,
  isValidPhone,
  isValidDate,
  isValidTrimester,
  isValidWeekNumber,
  isValidAttendanceArray,
  isValidIntakePeriod,
  isValidStudentId,
  isValidEmployeeId,
  isValidModuleCode,
  isValidGPA
};
```


/* ========== src\workers\notificationWorker.js ========== */
```javascript
require('dotenv').config();
const { notificationQueue, reminderQueue } = require('../config/redis');
const logger = require('../utils/logger');
const nodemailer = require('nodemailer');

// Create email transporter (configure based on your email service)
const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST || 'smtp.gmail.com',
  port: process.env.EMAIL_PORT || 587,
  secure: false,
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD
  }
});

// Email templates
const emailTemplates = {
  'activity-reminder': (data) => ({
    subject: data.subject,
    html: `
      <h2>Activity Log Reminder</h2>
      <p>Dear ${data.facilitatorName},</p>
      <p>This is a reminder to submit your activity log for:</p>
      <ul>
        <li><strong>Course:</strong> ${data.courseName}</li>
        <li><strong>Class:</strong> ${data.className}</li>
        <li><strong>Cohort:</strong> ${data.cohortName}</li>
        <li><strong>Week:</strong> ${data.weekNumber}</li>
      </ul>
      <p>Please submit your activity log by <strong>${new Date(data.dueDate).toLocaleString()}</strong>.</p>
      <p>Best regards,<br>Course Management System</p>
    `
  }),
  
  'manager-alert': (data) => ({
    subject: data.subject,
    html: `
      <h2>${data.alertType.replace(/-/g, ' ').toUpperCase()}</h2>
      <p>Dear ${data.managerName},</p>
      ${generateAlertContent(data.alertType, data)}
      <p>Best regards,<br>Course Management System</p>
    `
  })
};

function generateAlertContent(alertType, data) {
  switch (alertType) {
    case 'missing-activity-log':
      return `
        <p>The following activity log is missing:</p>
        <ul>
          <li><strong>Facilitator:</strong> ${data.facilitatorName}</li>
          <li><strong>Course:</strong> ${data.courseName}</li>
          <li><strong>Week:</strong> ${data.weekNumber}</li>
        </ul>
        <p>Please follow up with the facilitator.</p>
      `;
    
    case 'activity-submitted':
      return `
        <p>An activity log has been submitted:</p>
        <ul>
          <li><strong>Facilitator:</strong> ${data.facilitatorName}</li>
          <li><strong>Course:</strong> ${data.courseName}</li>
          <li><strong>Week:</strong> ${data.weekNumber}</li>
          <li><strong>Completion:</strong> ${data.completionPercentage}%</li>
          <li><strong>Submitted at:</strong> ${new Date(data.submittedAt).toLocaleString()}</li>
        </ul>
      `;
    
    case 'deadline-missed':
      return `
        <p>The deadline has been missed for:</p>
        <ul>
          <li><strong>Facilitator:</strong> ${data.facilitatorName}</li>
          <li><strong>Course:</strong> ${data.courseName}</li>
          <li><strong>Week:</strong> ${data.weekNumber}</li>
        </ul>
        <p>Immediate action required.</p>
      `;
    
    default:
      return '<p>System notification.</p>';
  }
}

// Process email notifications
notificationQueue.process('email', async (job) => {
  const { to, subject, template, data } = job.data;
  
  try {
    const emailTemplate = emailTemplates[template];
    if (!emailTemplate) {
      throw new Error(`Email template '${template}' not found`);
    }
    
    const emailContent = emailTemplate({ ...data, subject });
    
    // In development, log the email instead of sending
    if (process.env.NODE_ENV === 'development') {
      logger.info('Email notification (dev mode):', {
        to,
        subject: emailContent.subject,
        template
      });
      return { success: true, mode: 'development' };
    }
    
    // Send actual email in production
    const info = await transporter.sendMail({
      from: `"Course Management System" <${process.env.EMAIL_USER}>`,
      to,
      subject: emailContent.subject,
      html: emailContent.html
    });
    
    logger.info(`Email sent: ${info.messageId}`);
    return { success: true, messageId: info.messageId };
  } catch (error) {
    logger.error('Failed to send email:', error);
    throw error;
  }
});

// Process reminder notifications
reminderQueue.process('activity-reminder', async (job) => {
  try {
    // This processor could be expanded to handle different types of reminders
    logger.info('Processing reminder:', job.data);
    
    // Add the actual notification to the notification queue
    await notificationQueue.add('email', job.data);
    
    return { success: true };
  } catch (error) {
    logger.error('Failed to process reminder:', error);
    throw error;
  }
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, closing queues...');
  await notificationQueue.close();
  await reminderQueue.close();
  process.exit(0);
});

logger.info('Notification worker started');
logger.info(`Processing queues: notifications, reminders`);

// Keep the worker running
process.stdin.resume();
```


/* ========== tests\fixtures\testData.js ========== */
```javascript
const bcrypt = require("bcrypt")

const testUsers = {
  admin: {
    email: "admin@test.com",
    password: "Admin123!",
    firstName: "Test",
    lastName: "Admin",
    role: "admin",
    isActive: true,
  },
  manager: {
    email: "manager@test.com",
    password: "Manager123!",
    firstName: "Test",
    lastName: "Manager",
    role: "manager",
    isActive: true,
  },
  facilitator: {
    email: "facilitator@test.com",
    password: "Facilitator123!",
    firstName: "Test",
    lastName: "Facilitator",
    role: "facilitator",
    isActive: true,
  },
  student: {
    email: "student@test.com",
    password: "Student123!",
    firstName: "Test",
    lastName: "Student",
    role: "student",
    isActive: true,
  },
}

const testModules = [
  {
    code: "CS101",
    name: "Introduction to Computer Science",
    description: "Basic concepts of computer science",
    credits: 3,
    level: "100",
    isActive: true,
  },
  {
    code: "CS201",
    name: "Data Structures and Algorithms",
    description: "Study of data organization and algorithmic thinking",
    credits: 4,
    level: "200",
    isActive: true,
  },
  {
    code: "SE301",
    name: "Software Engineering",
    description: "Software development methodologies",
    credits: 3,
    level: "300",
    isActive: true,
  },
]

const testClasses = [
  {
    name: "2025S",
    year: 2025,
    section: "S",
    description: "Spring 2025",
  },
  {
    name: "2025F",
    year: 2025,
    section: "F",
    description: "Fall 2025",
  },
]

const testCohorts = [
  {
    name: "Computer Science 2025",
    code: "CS2025",
    startDate: "2025-01-01",
    endDate: "2028-12-31",
    program: "Computer Science",
    isActive: true,
  },
  {
    name: "Software Engineering 2025",
    code: "SE2025",
    startDate: "2025-01-01",
    endDate: "2028-12-31",
    program: "Software Engineering",
    isActive: true,
  },
]

const testModes = [
  {
    name: "Online",
    description: "Online delivery",
    requiresPhysicalPresence: false,
  },
  {
    name: "In-person",
    description: "Traditional classroom delivery",
    requiresPhysicalPresence: true,
  },
  {
    name: "Hybrid",
    description: "Mix of online and in-person",
    requiresPhysicalPresence: true,
  },
]

const createTestCourseOffering = (moduleId, classId, cohortId, facilitatorId, modeId) => ({
  moduleId,
  classId,
  cohortId,
  facilitatorId,
  modeId,
  trimester: 1,
  intakePeriod: "HT1",
  startDate: "2025-09-01",
  endDate: "2025-12-15",
  maxStudents: 30,
  status: "active",
})

const createTestActivityLog = (allocationId, weekNumber = 1) => ({
  allocationId,
  weekNumber,
  attendance: [true, true, false, true, true],
  formativeOneGrading: "Done",
  formativeTwoGrading: "Pending",
  summativeGrading: "Not Started",
  courseModeration: "Done",
  intranetSync: "Done",
  gradeBookStatus: "Pending",
  notes: "Test activity log",
})

const createTestManager = (userId) => ({
  userId,
  employeeId: "MGR001",
  department: "Computer Science",
  managementLevel: "senior",
  canApproveAllocations: true,
})

const createTestFacilitator = (userId) => ({
  userId,
  employeeId: "FAC001",
  department: "Computer Science",
  specialization: "Software Development",
  experienceYears: 5,
  maxCourseLoad: 4,
  currentCourseLoad: 0,
  isAvailable: true,
})

const createTestStudent = (userId, cohortId) => ({
  userId,
  studentId: "202400001",
  cohortId,
  enrollmentDate: new Date(),
  expectedGraduation: new Date("2027-12-31"),
  status: "active",
})

// Helper function to hash passwords for tests
const hashPassword = async (password) => {
  return await bcrypt.hash(password, 10)
}

// JWT tokens for testing
const generateTestTokens = () => {
  const jwt = require("jsonwebtoken")
  const secret = process.env.JWT_SECRET || "test-secret"

  return {
    adminToken: jwt.sign({ id: 1, role: "admin" }, secret, { expiresIn: "1h" }),
    managerToken: jwt.sign({ id: 2, role: "manager" }, secret, { expiresIn: "1h" }),
    facilitatorToken: jwt.sign({ id: 3, role: "facilitator" }, secret, { expiresIn: "1h" }),
    studentToken: jwt.sign({ id: 4, role: "student" }, secret, { expiresIn: "1h" }),
  }
}

module.exports = {
  testUsers,
  testModules,
  testClasses,
  testCohorts,
  testModes,
  createTestCourseOffering,
  createTestActivityLog,
  createTestManager,
  createTestFacilitator,
  createTestStudent,
  hashPassword,
  generateTestTokens,
}
```


/* ========== tests\integration\activityTracker.test.js ========== */
```javascript
const request = require('supertest');
const app = require('../../src/app');
const { sequelize } = require('../../src/models');
const { generateTestTokens } = require('../fixtures/testData');

describe('Activity Tracker Integration Tests', () => {
  let managerToken, facilitatorToken;
  let testCourseOffering, testFacilitator;

  beforeAll(async () => {
    await sequelize.sync({ force: true });
    
    const tokens = generateTestTokens();
    managerToken = tokens.managerToken;
    facilitatorToken = tokens.facilitatorToken;

    // Set up test data
    const { 
      Module, Class, Cohort, Mode, CourseOffering, 
      User, Facilitator 
    } = require('../../src/models');
    
    const testModule = await Module.create({
      code: 'CS101',
      name: 'Test Module',
      credits: 3,
      level: '100'
    });

    const testClass = await Class.create({
      name: '2025S',
      year: 2025,
      section: 'S'
    });

    const testCohort = await Cohort.create({
      name: 'Test Cohort',
      code: 'TC2025',
      startDate: '2025-01-01',
      endDate: '2028-12-31',
      program: 'Test Program'
    });

    const testMode = await Mode.create({
      name: 'Online',
      description: 'Online delivery'
    });

    const facilitatorUser = await User.create({
      id: 3, // Match the token
      email: 'facilitator@test.com',
      password: 'Password123!',
      firstName: 'John',
      lastName: 'Facilitator',
      role: 'facilitator'
    });

    testFacilitator = await Facilitator.create({
      userId: facilitatorUser.id,
      employeeId: 'FAC001',
      department: 'Computer Science'
    });

    testCourseOffering = await CourseOffering.create({
      moduleId: testModule.id,
      classId: testClass.id,
      cohortId: testCohort.id,
      facilitatorId: testFacilitator.id,
      modeId: testMode.id,
      trimester: 1,
      intakePeriod: 'HT1',
      startDate: '2025-09-01',
      endDate: '2025-12-15'
    });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  describe('Activity Log Management', () => {
    it('should allow facilitator to create activity log', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true, true, false, true, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Pending',
        summativeGrading: 'Not Started',
        courseModeration: 'Done',
        intranetSync: 'Done',
        gradeBookStatus: 'Pending',
        notes: 'Test activity log'
      };

      const response = await request(app)
        .post('/api/activities')
        .set('Authorization', `Bearer ${facilitatorToken}`)
        .send(logData)
        .expect(201);

      expect(response.body.message).toBe('Activity log created successfully');
      expect(response.body.activityLog).toBeDefined();
    });

    it('should prevent duplicate activity logs for same week', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 2,
        attendance: [true, true, true]
      };

      // Create first log
      await request(app)
        .post('/api/activities')
        .set('Authorization', `Bearer ${facilitatorToken}`)
        .send(logData)
        .expect(201);

      // Attempt duplicate
      await request(app)
        .post('/api/activities')
        .set('Authorization', `Bearer ${facilitatorToken}`)
        .send(logData)
        .expect(409);
    });

    it('should allow manager to view all activity logs', async () => {
      const response = await request(app)
        .get('/api/activities')
        .set('Authorization', `Bearer ${managerToken}`)
        .expect(200);

      expect(response.body.activityLogs).toBeDefined();
      expect(response.body.pagination).toBeDefined();
    });

    it('should allow facilitator to view only their logs', async () => {
      const response = await request(app)
        .get('/api/activities/my-logs')
        .set('Authorization', `Bearer ${facilitatorToken}`)
        .expect(200);

      expect(response.body.activityLogs).toBeDefined();
    });

    it('should provide weekly summary for managers', async () => {
      const response = await request(app)
        .get('/api/activities/summary?weekNumber=1')
        .set('Authorization', `Bearer ${managerToken}`)
        .expect(200);

      expect(response.body.weekNumber).toBe(1);
      expect(response.body.totalExpected).toBeDefined();
      expect(response.body.totalSubmitted).toBeDefined();
    });
  });
});
```


/* ========== tests\integration\auth.test.js ========== */
```javascript
const request = require('supertest');
const app = require('../../src/app');
const { sequelize, User } = require('../../src/models');

describe('Authentication Integration Tests', () => {
  beforeAll(async () => {
    await sequelize.sync({ force: true });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  afterEach(async () => {
    await User.destroy({ where: {}, force: true });
  });

  describe('POST /api/auth/register', () => {
    it('should register a new manager', async () => {
      const userData = {
        email: 'manager@test.com',
        password: 'Password123!',
        firstName: 'John',
        lastName: 'Manager',
        role: 'manager',
        employeeId: 'MGR001',
        department: 'Computer Science'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body.message).toBe('Registration successful');
      expect(response.body.user.email).toBe(userData.email);
      expect(response.body.user.role).toBe('manager');
      expect(response.body.tokens).toBeDefined();
      expect(response.body.tokens.accessToken).toBeDefined();
      expect(response.body.tokens.refreshToken).toBeDefined();
    });

    it('should register a new facilitator', async () => {
      const userData = {
        email: 'facilitator@test.com',
        password: 'Password123!',
        firstName: 'Jane',
        lastName: 'Facilitator',
        role: 'facilitator',
        employeeId: 'FAC001',
        department: 'Computer Science',
        specialization: 'Web Development'
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body.user.role).toBe('facilitator');
      expect(response.body.user.facilitator).toBeDefined();
    });

    it('should register a new student', async () => {
      // First create a cohort for the student
      const { Cohort } = require('../../src/models');
      const cohort = await Cohort.create({
        name: 'Test Cohort',
        code: 'TC2025',
        startDate: '2025-01-01',
        endDate: '2028-12-31',
        program: 'Computer Science'
      });

      const userData = {
        email: 'student@test.com',
        password: 'Password123!',
        firstName: 'Alice',
        lastName: 'Student',
        role: 'student',
        studentId: '202500001',
        cohortId: cohort.id
      };

      const response = await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      expect(response.body.user.role).toBe('student');
      expect(response.body.user.student).toBeDefined();
    });

    it('should reject duplicate email', async () => {
      const userData = {
        email: 'test@test.com',
        password: 'Password123!',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(201);

      await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(409);
    });

    it('should reject invalid password', async () => {
      const userData = {
        email: 'test@test.com',
        password: 'weak',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      await request(app)
        .post('/api/auth/register')
        .send(userData)
        .expect(400);
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      const userData = {
        email: 'test@test.com',
        password: 'Password123!',
        firstName: 'John',
        lastName: 'Doe',
        role: 'admin'
      };

      await request(app)
        .post('/api/auth/register')
        .send(userData);
    });

    it('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@test.com',
          password: 'Password123!'
        })
        .expect(200);

      expect(response.body.message).toBe('Login successful');
      expect(response.body.tokens).toBeDefined();
      expect(response.body.user.email).toBe('test@test.com');
    });

    it('should reject invalid credentials', async () => {
      await request(app)
        .post('/api/auth/login')
        .send({
          email: 'test@test.com',
          password: 'wrongpassword'
        })
        .expect(401);
    });

    it('should reject non-existent user', async () => {
      await request(app)
        .post('/api/auth/login')
        .send({
          email: 'nonexistent@test.com',
          password: 'Password123!'
        })
        .expect(401);
    });
  });
});
```


/* ========== tests\integration\courseAllocation.test.js ========== */
```javascript
const request = require('supertest');
const app = require('../../src/app');
const { sequelize } = require('../../src/models');
const { generateTestTokens } = require('../fixtures/testData');

describe('Course Allocation Integration Tests', () => {
  let managerToken, facilitatorToken, studentToken;
  let testModule, testClass, testCohort, testMode, testFacilitator;

  beforeAll(async () => {
    await sequelize.sync({ force: true });
    
    // Create test users and get tokens
    const tokens = generateTestTokens();
    managerToken = tokens.managerToken;
    facilitatorToken = tokens.facilitatorToken;
    studentToken = tokens.studentToken;

    // Create test data
    const { Module, Class, Cohort, Mode, User, Facilitator } = require('../../src/models');
    
    testModule = await Module.create({
      code: 'CS101',
      name: 'Intro to CS',
      credits: 3,
      level: '100'
    });

    testClass = await Class.create({
      name: '2025S',
      year: 2025,
      section: 'S'
    });

    testCohort = await Cohort.create({
      name: 'CS 2025',
      code: 'CS2025',
      startDate: '2025-01-01',
      endDate: '2028-12-31',
      program: 'Computer Science'
    });

    testMode = await Mode.create({
      name: 'Online',
      description: 'Online delivery'
    });

    const facilitatorUser = await User.create({
      email: 'facilitator@test.com',
      password: 'Password123!',
      firstName: 'John',
      lastName: 'Facilitator',
      role: 'facilitator'
    });

    testFacilitator = await Facilitator.create({
      userId: facilitatorUser.id,
      employeeId: 'FAC001',
      department: 'Computer Science'
    });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  describe('Course Offering Management', () => {
    it('should allow manager to create course offering', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        facilitatorId: testFacilitator.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15',
        maxStudents: 30
      };

      const response = await request(app)
        .post('/api/courses')
        .set('Authorization', `Bearer ${managerToken}`)
        .send(offeringData)
        .expect(201);

      expect(response.body.message).toBe('Course offering created successfully');
      expect(response.body.courseOffering).toBeDefined();
    });

    it('should prevent duplicate course offerings', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15'
      };

      // Create first offering
      await request(app)
        .post('/api/courses')
        .set('Authorization', `Bearer ${managerToken}`)
        .send(offeringData)
        .expect(201);

      // Attempt to create duplicate
      await request(app)
        .post('/api/courses')
        .set('Authorization', `Bearer ${managerToken}`)
        .send(offeringData)
        .expect(409);
    });

    it('should deny student access to create course offering', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15'
      };

      await request(app)
        .post('/api/courses')
        .set('Authorization', `Bearer ${studentToken}`)
        .send(offeringData)
        .expect(403);
    });

    it('should allow filtering course offerings', async () => {
      const response = await request(app)
        .get('/api/courses?trimester=1&status=planned')
        .set('Authorization', `Bearer ${managerToken}`)
        .expect(200);

      expect(response.body.courseOfferings).toBeDefined();
      expect(response.body.pagination).toBeDefined();
    });
  });

  describe('Module Management', () => {
    it('should allow manager to create module', async () => {
      const moduleData = {
        code: 'CS201',
        name: 'Data Structures',
        description: 'Advanced data structures',
        credits: 4,
        level: '200'
      };

      const response = await request(app)
        .post('/api/courses/modules')
        .set('Authorization', `Bearer ${managerToken}`)
        .send(moduleData)
        .expect(201);

      expect(response.body.message).toBe('Module created successfully');
      expect(response.body.module.code).toBe('CS201');
    });

    it('should reject invalid module code format', async () => {
      const moduleData = {
        code: 'INVALID',
        name: 'Invalid Module',
        credits: 3,
        level: '100'
      };

      await request(app)
        .post('/api/courses/modules')
        .set('Authorization', `Bearer ${managerToken}`)
        .send(moduleData)
        .expect(400);
    });

    it('should allow all authenticated users to view modules', async () => {
      await request(app)
        .get('/api/courses/modules')
        .set('Authorization', `Bearer ${studentToken}`)
        .expect(200);
    });
  });
});
```


/* ========== tests\setup.js ========== */
```javascript
// tests/setup.js

// Set test environment
process.env.NODE_ENV = 'test';
process.env.JWT_SECRET = 'test-secret-key';
process.env.JWT_REFRESH_SECRET = 'test-refresh-secret';

// Test database configuration
process.env.DB_NAME = 'course_management_test';
process.env.DB_USER = 'root';
process.env.DB_PASSWORD = '';
process.env.DB_HOST = 'localhost';
process.env.DB_PORT = '3306';

// Mock Redis for tests
jest.mock('../src/config/redis', () => ({
  redisClient: {
    connect: jest.fn(),
    on: jest.fn(),
    get: jest.fn(),
    set: jest.fn(),
    del: jest.fn()
  },
  notificationQueue: {
    add: jest.fn(),
    process: jest.fn(),
    on: jest.fn()
  },
  reminderQueue: {
    add: jest.fn(),
    process: jest.fn(),
    on: jest.fn()
  }
}));

// Global test timeout
jest.setTimeout(30000);

// Suppress console logs during tests
global.console = {
  ...console,
  log: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn(),
  debug: jest.fn()
};

// Clean up after each test
afterEach(async () => {
  // Clear all mocks
  jest.clearAllMocks();
});
```


/* ========== tests\testDbConfig.js ========== */
```javascript
// tests/testDbConfig.js
const { Sequelize } = require('sequelize');

// Create a separate test database configuration
const createTestDatabase = () => {
  const sequelize = new Sequelize(
    process.env.DB_NAME || 'course_management_test',
    process.env.DB_USER || 'root',
    process.env.DB_PASSWORD || '',
    {
      host: process.env.DB_HOST || 'localhost',
      port: process.env.DB_PORT || 3306,
      dialect: 'mysql',
      logging: false, // Disable logging in tests
      pool: {
        max: 5,
        min: 0,
        acquire: 30000,
        idle: 10000
      },
      define: {
        timestamps: true,
        underscored: true,
        paranoid: true
      }
    }
  );

  return sequelize;
};

module.exports = { createTestDatabase };
```


/* ========== tests\unit\models\ActivityTracker.test.js ========== */
```javascript
const { sequelize, ActivityTracker, CourseOffering, Module, Class, Cohort, Mode } = require('../../../src/models');

describe('ActivityTracker Model', () => {
  let testCourseOffering;

  beforeAll(async () => {
    await sequelize.sync({ force: true });
    
    // Create test dependencies
    const testModule = await Module.create({
      code: 'CS201',
      name: 'Data Structures',
      credits: 3,
      level: '200'
    });

    const testClass = await Class.create({
      name: '2025F',
      year: 2025,
      section: 'F'
    });

    const testCohort = await Cohort.create({
      name: 'Computer Science 2025',
      code: 'CS2025',
      startDate: '2025-01-01',
      endDate: '2028-12-31',
      program: 'Computer Science'
    });

    const testMode = await Mode.create({
      name: 'In-person',
      description: 'In-person delivery'
    });

    testCourseOffering = await CourseOffering.create({
      moduleId: testModule.id,
      classId: testClass.id,
      cohortId: testCohort.id,
      modeId: testMode.id,
      trimester: 1,
      intakePeriod: 'FT',
      startDate: '2025-09-01',
      endDate: '2025-12-15'
    });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  afterEach(async () => {
    await ActivityTracker.destroy({ where: {}, force: true });
  });

  describe('Activity Tracker Creation', () => {
    it('should create an activity log with valid data', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true, true, false, true, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Pending',
        summativeGrading: 'Not Started',
        courseModeration: 'Done',
        intranetSync: 'Done',
        gradeBookStatus: 'Pending',
        notes: 'Student 3 was absent'
      };

      const log = await ActivityTracker.create(logData);

      expect(log.id).toBeDefined();
      expect(log.weekNumber).toBe(1);
      expect(log.attendance).toEqual([true, true, false, true, true]);
      expect(log.formativeOneGrading).toBe('Done');
      expect(log.reminderCount).toBe(0);
    });

    it('should enforce unique constraint on allocation-week combination', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true, true, true]
      };

      await ActivityTracker.create(logData);
      await expect(ActivityTracker.create(logData)).rejects.toThrow();
    });

    it('should validate attendance array contains only booleans', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true, 'present', false] // Invalid
      };

      await expect(ActivityTracker.create(logData)).rejects.toThrow();
    });

    it('should validate week number range', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 17, // Invalid (max is 16)
        attendance: [true, true]
      };

      await expect(ActivityTracker.create(logData)).rejects.toThrow();
    });

    it('should validate grading status enum values', async () => {
      const logData = {
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true],
        formativeOneGrading: 'Complete' // Invalid enum value
      };

      await expect(ActivityTracker.create(logData)).rejects.toThrow();
    });
  });

  describe('Instance Methods', () => {
    let activityLog;

    beforeEach(async () => {
      activityLog = await ActivityTracker.create({
        allocationId: testCourseOffering.id,
        weekNumber: 1,
        attendance: [true, true, false, true],
        formativeOneGrading: 'Done',
        formativeTwoGrading: 'Done',
        summativeGrading: 'Pending',
        courseModeration: 'Done',
        intranetSync: 'Done',
        gradeBookStatus: 'Not Started'
      });
    });

    it('should check if activity log is complete', () => {
      expect(activityLog.isComplete()).toBe(false);

      activityLog.summativeGrading = 'Done';
      activityLog.gradeBookStatus = 'Done';
      expect(activityLog.isComplete()).toBe(true);
    });

    it('should calculate completion percentage', () => {
      // 4 out of 6 tasks done + attendance = 5/7 = ~71%
      expect(activityLog.getCompletionPercentage()).toBe(71);

      activityLog.summativeGrading = 'Done';
      activityLog.gradeBookStatus = 'Done';
      expect(activityLog.getCompletionPercentage()).toBe(100);

      // Test with no attendance
      activityLog.attendance = [];
      expect(activityLog.getCompletionPercentage()).toBe(86); // 6/7
    });

    it('should mark as submitted', async () => {
      expect(activityLog.submittedAt).toBeNull();

      await activityLog.markSubmitted();
      await activityLog.reload();

      expect(activityLog.submittedAt).toBeDefined();
      expect(activityLog.submittedAt).toBeInstanceOf(Date);
    });

    it('should increment reminder count', async () => {
      expect(activityLog.reminderCount).toBe(0);
      expect(activityLog.lastReminderSent).toBeNull();

      await activityLog.incrementReminderCount();
      await activityLog.reload();

      expect(activityLog.reminderCount).toBe(1);
      expect(activityLog.lastReminderSent).toBeDefined();
    });
  });

  describe('Default Values', () => {
    it('should set default values for grading statuses', async () => {
      const log = await ActivityTracker.create({
        allocationId: testCourseOffering.id,
        weekNumber: 2,
        attendance: [true]
      });

      expect(log.formativeOneGrading).toBe('Not Started');
      expect(log.formativeTwoGrading).toBe('Not Started');
      expect(log.summativeGrading).toBe('Not Started');
      expect(log.courseModeration).toBe('Not Started');
      expect(log.intranetSync).toBe('Not Started');
      expect(log.gradeBookStatus).toBe('Not Started');
    });
  });
});
```


/* ========== tests\unit\models\CourseOffering.test.js ========== */
```javascript
const { sequelize, CourseOffering, Module, Class, Cohort, Facilitator, Mode } = require('../../../src/models');

describe('CourseOffering Model', () => {
  let testModule, testClass, testCohort, testFacilitator, testMode;

  beforeAll(async () => {
    await sequelize.sync({ force: true });
    
    // Create test data
    testModule = await Module.create({
      code: 'CS101',
      name: 'Introduction to Computer Science',
      description: 'Basic CS concepts',
      credits: 3,
      level: '100'
    });

    testClass = await Class.create({
      name: '2025S',
      year: 2025,
      section: 'S'
    });

    testCohort = await Cohort.create({
      name: 'Software Engineering 2025',
      code: 'SE2025',
      startDate: '2025-01-01',
      endDate: '2028-12-31',
      program: 'Software Engineering'
    });

    testMode = await Mode.create({
      name: 'Online',
      description: 'Online delivery'
    });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  afterEach(async () => {
    await CourseOffering.destroy({ where: {}, force: true });
  });

  describe('Course Offering Creation', () => {
    it('should create a course offering with valid data', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15',
        maxStudents: 30
      };

      const offering = await CourseOffering.create(offeringData);

      expect(offering.id).toBeDefined();
      expect(offering.trimester).toBe(1);
      expect(offering.intakePeriod).toBe('HT1');
      expect(offering.status).toBe('planned');
      expect(offering.enrolledStudents).toBe(0);
    });

    it('should enforce unique constraint on module-class-cohort-trimester-intake combination', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15'
      };

      await CourseOffering.create(offeringData);
      await expect(CourseOffering.create(offeringData)).rejects.toThrow();
    });

    it('should validate trimester range', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 4, // Invalid
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15'
      };

      await expect(CourseOffering.create(offeringData)).rejects.toThrow();
    });

    it('should validate end date is after start date', async () => {
      const offeringData = {
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-12-15',
        endDate: '2025-09-01' // Before start date
      };

      await expect(CourseOffering.create(offeringData)).rejects.toThrow();
    });
  });

  describe('Instance Methods', () => {
    let offering;

    beforeEach(async () => {
      offering = await CourseOffering.create({
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15',
        maxStudents: 30,
        enrolledStudents: 10,
        status: 'active'
      });
    });

    it('should check if course is available', () => {
      expect(offering.isAvailable()).toBe(true);
      
      offering.enrolledStudents = 30;
      expect(offering.isAvailable()).toBe(false);
      
      offering.status = 'completed';
      expect(offering.isAvailable()).toBe(false);
    });

    it('should calculate remaining slots', () => {
      expect(offering.getRemainingSlots()).toBe(20);
      
      offering.enrolledStudents = 30;
      expect(offering.getRemainingSlots()).toBe(0);
    });

    it('should increment enrollment', async () => {
      const initialEnrolled = offering.enrolledStudents;
      await offering.incrementEnrollment();
      
      await offering.reload();
      expect(offering.enrolledStudents).toBe(initialEnrolled + 1);
    });

    it('should not increment enrollment if course is full', async () => {
      offering.enrolledStudents = offering.maxStudents;
      await offering.save();
      
      await expect(offering.incrementEnrollment()).rejects.toThrow('Course is full');
    });

    it('should decrement enrollment', async () => {
      const initialEnrolled = offering.enrolledStudents;
      await offering.decrementEnrollment();
      
      await offering.reload();
      expect(offering.enrolledStudents).toBe(initialEnrolled - 1);
    });

    it('should not decrement enrollment below zero', async () => {
      offering.enrolledStudents = 0;
      await offering.save();
      
      await expect(offering.decrementEnrollment()).rejects.toThrow('No students enrolled');
    });
  });

  describe('Associations', () => {
    it('should load associated models', async () => {
      const offering = await CourseOffering.create({
        moduleId: testModule.id,
        classId: testClass.id,
        cohortId: testCohort.id,
        modeId: testMode.id,
        trimester: 1,
        intakePeriod: 'HT1',
        startDate: '2025-09-01',
        endDate: '2025-12-15'
      });

      const loaded = await CourseOffering.findByPk(offering.id, {
        include: ['module', 'class', 'cohort', 'mode']
      });

      expect(loaded.module.code).toBe('CS101');
      expect(loaded.class.name).toBe('2025S');
      expect(loaded.cohort.code).toBe('SE2025');
      expect(loaded.mode.name).toBe('Online');
    });
  });
});
```


/* ========== tests\unit\models\User.test.js ========== */
```javascript
const { sequelize, User } = require('../../../src/models');
const bcrypt = require('bcrypt');

describe('User Model', () => {
  beforeAll(async () => {
    await sequelize.sync({ force: true });
  });

  afterAll(async () => {
    await sequelize.close();
  });

  afterEach(async () => {
    await User.destroy({ where: {}, force: true });
  });

  describe('User Creation', () => {
    it('should create a user with valid data', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      const user = await User.create(userData);

      expect(user.id).toBeDefined();
      expect(user.email).toBe(userData.email);
      expect(user.firstName).toBe(userData.firstName);
      expect(user.lastName).toBe(userData.lastName);
      expect(user.role).toBe(userData.role);
      expect(user.isActive).toBe(true);
    });

    it('should hash the password before saving', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      const user = await User.create(userData);
      
      expect(user.password).not.toBe(userData.password);
      const isPasswordValid = await bcrypt.compare(userData.password, user.password);
      expect(isPasswordValid).toBe(true);
    });

    it('should throw error for invalid email', async () => {
      const userData = {
        email: 'invalid-email',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      await expect(User.create(userData)).rejects.toThrow();
    });

    it('should throw error for duplicate email', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      };

      await User.create(userData);
      await expect(User.create(userData)).rejects.toThrow();
    });

    it('should enforce role enum values', async () => {
      const userData = {
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'invalid-role'
      };

      await expect(User.create(userData)).rejects.toThrow();
    });
  });

  describe('Instance Methods', () => {
    it('should validate correct password', async () => {
      const password = 'password123';
      const user = await User.create({
        email: 'test@example.com',
        password,
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      const isValid = await user.validatePassword(password);
      expect(isValid).toBe(true);
    });

    it('should reject incorrect password', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      const isValid = await user.validatePassword('wrongpassword');
      expect(isValid).toBe(false);
    });

    it('should return full name', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      expect(user.getFullName()).toBe('John Doe');
    });

    it('should exclude sensitive fields in toJSON', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      const json = user.toJSON();
      
      expect(json.password).toBeUndefined();
      expect(json.resetPasswordToken).toBeUndefined();
      expect(json.resetPasswordExpires).toBeUndefined();
      expect(json.deletedAt).toBeUndefined();
      expect(json.email).toBe('test@example.com');
    });
  });

  describe('User Update', () => {
    it('should hash password on update', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      const oldPasswordHash = user.password;
      
      user.password = 'newpassword123';
      await user.save();

      expect(user.password).not.toBe(oldPasswordHash);
      expect(user.password).not.toBe('newpassword123');
      
      const isValid = await user.validatePassword('newpassword123');
      expect(isValid).toBe(true);
    });

    it('should update lastLogin field', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      expect(user.lastLogin).toBeNull();

      const loginTime = new Date();
      user.lastLogin = loginTime;
      await user.save();

      expect(user.lastLogin).toEqual(loginTime);
    });
  });

  describe('Soft Delete', () => {
    it('should soft delete user', async () => {
      const user = await User.create({
        email: 'test@example.com',
        password: 'password123',
        firstName: 'John',
        lastName: 'Doe',
        role: 'student'
      });

      await user.destroy();

      const foundUser = await User.findByPk(user.id);
      expect(foundUser).toBeNull();

      const foundUserWithDeleted = await User.findByPk(user.id, { paranoid: false });
      expect(foundUserWithDeleted).toBeDefined();
      expect(foundUserWithDeleted.deletedAt).toBeDefined();
    });
  });
});
```


/* ========== tests\unit\utils\helpers.test.js ========== */
```javascript
const helpers = require('../../../src/utils/helpers');

describe('Helper Functions', () => {
  describe('generateRandomString', () => {
    it('should generate string of specified length', () => {
      const str = helpers.generateRandomString(16);
      expect(str).toHaveLength(16);
      expect(typeof str).toBe('string');
    });

    it('should generate different strings each time', () => {
      const str1 = helpers.generateRandomString(32);
      const str2 = helpers.generateRandomString(32);
      expect(str1).not.toBe(str2);
    });
  });

  describe('calculateOffset', () => {
    it('should calculate correct offset for pagination', () => {
      expect(helpers.calculateOffset(1, 10)).toBe(0);
      expect(helpers.calculateOffset(2, 10)).toBe(10);
      expect(helpers.calculateOffset(5, 20)).toBe(80);
    });
  });

  describe('formatPaginationResponse', () => {
    it('should format pagination metadata correctly', () => {
      const result = helpers.formatPaginationResponse(100, 3, 10);
      
      expect(result).toEqual({
        total: 100,
        page: 3,
        limit: 10,
        pages: 10,
        hasNext: true,
        hasPrev: true
      });
    });

    it('should handle edge cases', () => {
      const firstPage = helpers.formatPaginationResponse(50, 1, 10);
      expect(firstPage.hasPrev).toBe(false);
      expect(firstPage.hasNext).toBe(true);

      const lastPage = helpers.formatPaginationResponse(50, 5, 10);
      expect(lastPage.hasPrev).toBe(true);
      expect(lastPage.hasNext).toBe(false);
    });
  });

  describe('generateEmployeeId', () => {
    it('should generate employee ID with correct format', () => {
      const id = helpers.generateEmployeeId();
      expect(id).toMatch(/^EMP[A-Z0-9]+$/);
      expect(id.length).toBeGreaterThan(11);
    });

    it('should generate unique IDs', () => {
      const ids = new Set();
      for (let i = 0; i < 100; i++) {
        ids.add(helpers.generateEmployeeId());
      }
      expect(ids.size).toBe(100);
    });
  });

  describe('generateStudentId', () => {
    it('should generate student ID with current year', () => {
      const id = helpers.generateStudentId();
      const currentYear = new Date().getFullYear();
      expect(id).toMatch(new RegExp(`^${currentYear}\\d{5}$`));
    });

    it('should generate ID with specified year', () => {
      const id = helpers.generateStudentId(2025);
      expect(id).toMatch(/^2025\d{5}$/);
    });
  });

  describe('calculateWeekNumber', () => {
    it('should calculate correct week number', () => {
      const startDate = new Date('2025-01-01');
      const currentDate = new Date('2025-01-08'); // 7 days later
      expect(helpers.calculateWeekNumber(startDate, currentDate)).toBe(2);

      const laterDate = new Date('2025-01-15'); // 14 days later
      expect(helpers.calculateWeekNumber(startDate, laterDate)).toBe(3);
    });

    it('should handle same day as week 1', () => {
      const date = new Date('2025-01-01');
      expect(helpers.calculateWeekNumber(date, date)).toBe(1);
    });

    it('should handle dates before start date', () => {
      const startDate = new Date('2025-01-01');
      const beforeDate = new Date('2024-12-25');
      expect(helpers.calculateWeekNumber(startDate, beforeDate)).toBe(0);
    });

    it('should handle edge cases for week calculation', () => {
      const startDate = new Date('2025-01-01');
      
      // Day 1-6 should be week 1
      const day6 = new Date('2025-01-06');
      expect(helpers.calculateWeekNumber(startDate, day6)).toBe(1);
      
      // Day 7 should be week 2
      const day7 = new Date('2025-01-07');
      expect(helpers.calculateWeekNumber(startDate, day7)).toBe(1);
      
      // Day 8 should be week 2
      const day8 = new Date('2025-01-08');
      expect(helpers.calculateWeekNumber(startDate, day8)).toBe(2);
    });
  });

  describe('isValidDateRange', () => {
    it('should validate date ranges correctly', () => {
      const start = new Date('2025-01-01');
      const end = new Date('2025-12-31');
      expect(helpers.isValidDateRange(start, end)).toBe(true);

      const invalidEnd = new Date('2024-12-31');
      expect(helpers.isValidDateRange(start, invalidEnd)).toBe(false);
    });

    it('should handle string dates', () => {
      expect(helpers.isValidDateRange('2025-01-01', '2025-12-31')).toBe(true);
      expect(helpers.isValidDateRange('2025-12-31', '2025-01-01')).toBe(false);
    });
  });

  describe('formatDate', () => {
    it('should format date correctly', () => {
      const date = new Date('2025-01-15');
      const formatted = helpers.formatDate(date);
      expect(formatted).toBe('January 15, 2025');
    });

    it('should handle string dates', () => {
      const formatted = helpers.formatDate('2025-12-25');
      expect(formatted).toBe('December 25, 2025');
    });
  });

  describe('sleep', () => {
    it('should delay execution', async () => {
      const start = Date.now();
      await helpers.sleep(100);
      const end = Date.now();
      expect(end - start).toBeGreaterThanOrEqual(90); // Allow some margin
    });
  });

  describe('sanitizeInput', () => {
    it('should remove HTML tags and trim whitespace', () => {
      expect(helpers.sanitizeInput('  hello  ')).toBe('hello');
      expect(helpers.sanitizeInput('<script>alert("xss")</script>')).toBe('scriptalert("xss")/script');
      expect(helpers.sanitizeInput('normal text')).toBe('normal text');
    });

    it('should handle non-string inputs', () => {
      expect(helpers.sanitizeInput(123)).toBe(123);
      expect(helpers.sanitizeInput(null)).toBe(null);
      expect(helpers.sanitizeInput(undefined)).toBe(undefined);
    });
  });

  describe('hasRole', () => {
    it('should check if user has allowed role', () => {
      const user = { role: 'facilitator' };
      expect(helpers.hasRole(user, ['facilitator', 'manager'])).toBe(true);
      expect(helpers.hasRole(user, ['manager', 'admin'])).toBe(false);
      expect(helpers.hasRole(user, ['facilitator'])).toBe(true);
    });
  });

  describe('parseBoolean', () => {
    it('should parse various boolean representations', () => {
      expect(helpers.parseBoolean(true)).toBe(true);
      expect(helpers.parseBoolean(false)).toBe(false);
      expect(helpers.parseBoolean('true')).toBe(true);
      expect(helpers.parseBoolean('false')).toBe(false);
      expect(helpers.parseBoolean('1')).toBe(true);
      expect(helpers.parseBoolean('0')).toBe(false);
      expect(helpers.parseBoolean('yes')).toBe(true);
      expect(helpers.parseBoolean('no')).toBe(false);
    });
  });
});
```
